<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COHERENCE</title>
    <style>
       @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;600&family=IBM+Plex+Mono:wght@400;600&display=swap');

:root {
  /* shared “hub-ish” palette */
  --earth-deep: #1a1816;
  --stone-dark: #2a2724;
  --stone: #3a3530;
  --sand: #c4b8a5;
  --paper: #e7dfcf;
  --dawn: #a64c3c;

  --text-dim: rgba(196, 184, 165, 0.65);
  --text-mid: rgba(196, 184, 165, 0.82);
  --text-bright: rgba(231, 223, 207, 0.95);

  --panel: rgba(26, 24, 22, 0.62);
  --panel-strong: rgba(26, 24, 22, 0.78);
  --border: rgba(90, 85, 80, 0.35);
  --border-strong: rgba(196, 184, 165, 0.22);

  /* Coherence-specific accents (kept, but softened) */
  --signal-green: #79bfa1;
  --signal-amber: #caa86a;
  --signal-red: #c26a6a;

  --distortion: #b06a95;
  --anchor: #7fb6c2;
  --threshold: #c98b5b;
  --gold: #d7c07a;

  --shadow: rgba(0, 0, 0, 0.35);
}

* { margin: 0; padding: 0; box-sizing: border-box; }

html, body { height: 100%; }

body {
  font-family: 'IBM Plex Mono', monospace;
  color: var(--text-bright);
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 1.25rem;
  overflow: hidden;
  background:
    radial-gradient(circle at 20% 15%, rgba(166, 76, 60, 0.12) 0%, transparent 40%),
    radial-gradient(circle at 80% 25%, rgba(196, 184, 165, 0.10) 0%, transparent 45%),
    radial-gradient(circle at 55% 85%, rgba(121, 191, 161, 0.08) 0%, transparent 45%),
    linear-gradient(180deg, var(--earth-deep), #141210 70%, #11100f);
  position: relative;
}

/* subtle noise texture (kept, but gentler than the sci-fi overlay) */
body::after {
  content: '';
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 0;
  opacity: 0.20;
  background-image:
    url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.10'/%3E%3C/svg%3E");
}

.container {
  position: relative;
  z-index: 1;
  text-align: center;
  width: 100%;
  max-width: 900px;
}

header {
  margin-bottom: 1.25rem;
  animation: fadeIn 1.2s ease-out 0.1s both;
}

h1 {
  font-family: 'Cormorant Garamond', serif;
  font-weight: 600;
  letter-spacing: 0.18rem;
  font-size: clamp(2.0rem, 5vw, 3.0rem);
  color: var(--paper);
  text-shadow: 0 10px 30px rgba(0,0,0,0.35);
}

.subtitle {
  margin-top: 0.35rem;
  font-size: clamp(0.75rem, 1.8vw, 0.95rem);
  color: var(--text-dim);
  letter-spacing: 0.12rem;
  text-transform: lowercase;
  font-style: italic;
}

#game-container {
  display: inline-block;
  width: min(92vw, 660px);
  padding: 1.25rem;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 18px;
  box-shadow:
    0 18px 60px rgba(0, 0, 0, 0.45),
    inset 0 1px 0 rgba(255, 255, 255, 0.04);
  animation: fadeIn 1.1s ease-out 0.25s both;
}

#grid {
  display: grid;
  grid-template-columns: repeat(16, 1fr);
  gap: 2px;
  padding: 0.9rem;
  width: min(90vw, 600px);
  height: min(90vw, 600px);
  background: rgba(0,0,0,0.18);
  border: 1px solid var(--border-strong);
  border-radius: 14px;
  box-shadow:
    inset 0 0 24px rgba(0,0,0,0.35),
    inset 0 1px 0 rgba(255,255,255,0.03);
}

.cell {
  aspect-ratio: 1;
  border-radius: 6px;
  position: relative;
  transition: transform 0.12s ease, filter 0.2s ease, box-shadow 0.2s ease;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.05),
    0 1px 2px rgba(0,0,0,0.22);
}

/* Tile types - sigil-based aesthetic */
.ground {
  background: rgba(196, 184, 165, 0.06);
  border: 1px solid rgba(196, 184, 165, 0.08);
}

.boundary {
  background: rgba(196, 184, 165, 0.12);
  border: 1px solid rgba(196, 184, 165, 0.18);
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.04),
    0 2px 4px rgba(0,0,0,0.25);
}

/* ===== PLAYER SIGIL ===== */
/* Full diamond with asterisk - the complete signal */
.player {
  background: radial-gradient(circle at 50% 50%, rgba(121,191,161,0.35) 0%, rgba(121,191,161,0.08) 60%, transparent 100%);
  border: 1px solid rgba(121, 191, 161, 0.25);
  box-shadow:
    0 0 20px rgba(121, 191, 161, 0.25),
    0 0 40px rgba(121, 191, 161, 0.10);
  animation: playerPulse 2.4s ease-in-out infinite;
  overflow: visible;
}

.player::before {
  content: '';
  position: absolute;
  top: 15%;
  left: 15%;
  width: 70%;
  height: 70%;
  border: 2px solid rgba(121, 191, 161, 0.9);
  transform: rotate(45deg);
  box-shadow: inset 0 0 8px rgba(121, 191, 161, 0.3);
}

.player::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 60%;
  height: 60%;
  transform: translate(-50%, -50%);
  background:
    linear-gradient(0deg, transparent 45%, rgba(121,191,161,0.8) 48%, rgba(121,191,161,0.8) 52%, transparent 55%),
    linear-gradient(90deg, transparent 45%, rgba(121,191,161,0.8) 48%, rgba(121,191,161,0.8) 52%, transparent 55%),
    linear-gradient(45deg, transparent 45%, rgba(121,191,161,0.5) 48%, rgba(121,191,161,0.5) 52%, transparent 55%),
    linear-gradient(-45deg, transparent 45%, rgba(121,191,161,0.5) 48%, rgba(121,191,161,0.5) 52%, transparent 55%);
}

/* ===== DISTORTION SIGIL ===== */
/* Broken/fragmented diamond - corrupted signal */
.distortion {
  background: radial-gradient(circle at 50% 50%, rgba(176, 106, 149, 0.30) 0%, rgba(176, 106, 149, 0.08) 60%, transparent 100%);
  border: 1px solid rgba(176, 106, 149, 0.20);
  box-shadow:
    0 0 15px rgba(176, 106, 149, 0.20),
    0 0 30px rgba(176, 106, 149, 0.08);
  animation: distortionFlicker 3.5s ease-in-out infinite;
}

.distortion::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 20%;
  width: 60%;
  height: 60%;
  border: 2px solid rgba(176, 106, 149, 0.7);
  border-right-color: transparent;
  border-bottom-color: transparent;
  transform: rotate(45deg);
}

.distortion::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 50%;
  height: 50%;
  transform: translate(-50%, -50%);
  background:
    linear-gradient(135deg, transparent 40%, rgba(176,106,149,0.6) 48%, transparent 52%),
    linear-gradient(-135deg, transparent 40%, rgba(176,106,149,0.4) 48%, transparent 52%);
}

/* ===== ANCHOR SIGIL ===== */
/* Diamond with inner circle - stability/grounding */
.anchor {
  background: radial-gradient(circle at 50% 50%, rgba(127, 182, 194, 0.35) 0%, rgba(127, 182, 194, 0.08) 60%, transparent 100%);
  border: 1px solid rgba(127, 182, 194, 0.25);
  box-shadow:
    0 0 18px rgba(127, 182, 194, 0.22),
    0 0 35px rgba(127, 182, 194, 0.08);
  animation: anchorGlow 2.6s ease-in-out infinite;
}

.anchor::before {
  content: '';
  position: absolute;
  top: 18%;
  left: 18%;
  width: 64%;
  height: 64%;
  border: 2px solid rgba(127, 182, 194, 0.8);
  transform: rotate(45deg);
}

.anchor::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 35%;
  height: 35%;
  transform: translate(-50%, -50%);
  border: 2px solid rgba(127, 182, 194, 0.9);
  border-radius: 50%;
  box-shadow: 0 0 6px rgba(127, 182, 194, 0.4);
}

/* ===== THRESHOLD SIGIL ===== */
/* Horizontal gateway line - point of no return */
.threshold {
  background: linear-gradient(90deg, transparent 0%, rgba(201, 139, 91, 0.15) 30%, rgba(201, 139, 91, 0.15) 70%, transparent 100%);
  border: 1px solid rgba(201, 139, 91, 0.20);
  box-shadow:
    0 0 12px rgba(201, 139, 91, 0.15),
    inset 0 0 8px rgba(201, 139, 91, 0.08);
}

.threshold::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 10%;
  width: 80%;
  height: 2px;
  background: rgba(201, 139, 91, 0.8);
  transform: translateY(-50%);
  box-shadow: 0 0 8px rgba(201, 139, 91, 0.5);
}

.threshold::after {
  content: '';
  position: absolute;
  top: 25%;
  left: 35%;
  width: 30%;
  height: 50%;
  border: 1px solid rgba(201, 139, 91, 0.5);
  border-top: none;
  border-bottom: none;
}

/* ===== ARTIFACT SIGIL ===== */
/* Elaborate diamond with full star - power/transformation */
.artifact {
  background: radial-gradient(circle at 50% 50%, rgba(215, 192, 122, 0.40) 0%, rgba(215, 192, 122, 0.12) 50%, transparent 100%);
  border: 1px solid rgba(215, 192, 122, 0.30);
  box-shadow:
    0 0 22px rgba(215, 192, 122, 0.30),
    0 0 45px rgba(215, 192, 122, 0.12);
  animation: artifactSparkle 2.8s ease-in-out infinite;
}

.artifact::before {
  content: '';
  position: absolute;
  top: 12%;
  left: 12%;
  width: 76%;
  height: 76%;
  border: 2px solid rgba(215, 192, 122, 0.9);
  transform: rotate(45deg);
  box-shadow:
    inset 0 0 10px rgba(215, 192, 122, 0.25),
    0 0 8px rgba(215, 192, 122, 0.3);
}

.artifact::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 70%;
  height: 70%;
  transform: translate(-50%, -50%);
  background:
    linear-gradient(0deg, transparent 42%, rgba(215,192,122,0.9) 47%, rgba(215,192,122,0.9) 53%, transparent 58%),
    linear-gradient(90deg, transparent 42%, rgba(215,192,122,0.9) 47%, rgba(215,192,122,0.9) 53%, transparent 58%),
    linear-gradient(45deg, transparent 42%, rgba(215,192,122,0.6) 47%, rgba(215,192,122,0.6) 53%, transparent 58%),
    linear-gradient(-45deg, transparent 42%, rgba(215,192,122,0.6) 47%, rgba(215,192,122,0.6) 53%, transparent 58%);
}

/* ===== EXIT SIGIL ===== */
/* Open diamond frame - portal/escape */
.exit {
  background: radial-gradient(circle at 50% 50%, rgba(121,191,161,0.25) 0%, rgba(121,191,161,0.05) 60%, transparent 100%);
  border: 1px solid rgba(121, 191, 161, 0.20);
  box-shadow:
    0 0 18px rgba(121,191,161,0.18),
    0 0 35px rgba(121,191,161,0.08);
  animation: exitPulse 3.2s ease-in-out infinite;
}

.exit::before {
  content: '';
  position: absolute;
  top: 15%;
  left: 15%;
  width: 70%;
  height: 70%;
  border: 2px solid rgba(121, 191, 161, 0.7);
  transform: rotate(45deg);
}

.exit::after {
  content: '';
  position: absolute;
  top: 28%;
  left: 28%;
  width: 44%;
  height: 44%;
  border: 1px solid rgba(121, 191, 161, 0.5);
  transform: rotate(45deg);
  animation: exitInnerPulse 3.2s ease-in-out infinite;
}

#status {
  margin-top: 1rem;
  padding: 0.75rem 1rem;
  width: 100%;
  max-width: 600px;
  background: transparent;
  border: none;
  color: var(--text-dim);
  font-size: clamp(0.75rem, 1.6vw, 0.95rem);
  letter-spacing: 0.14rem;
  text-align: center;
}

.status-line { margin: 0.25rem 0; }

.coh-value { font-weight: 600; transition: color 0.3s ease; }
.coh-high { color: var(--signal-green); }
.coh-medium { color: var(--signal-amber); }
.coh-low { color: var(--signal-red); }

.state-stable { color: var(--signal-green); }
.state-searching { color: var(--signal-amber); }
.state-altered { color: var(--anchor); }
.state-critical { color: var(--signal-red); animation: textPulse 1.4s ease-in-out infinite; }

.instructions {
  margin-top: 1rem;
  font-size: clamp(0.6rem, 1.4vw, 0.8rem);
  color: var(--text-dim);
  letter-spacing: 0.1rem;
  line-height: 1.6;
  text-transform: lowercase;
  font-style: italic;
  animation: fadeIn 1.2s ease-out 0.55s both;
}

/* Mobile controls */
#mobile-controls {
  display: none;
  margin: 1rem auto 0;
  width: 180px;
  height: 180px;
  position: relative;
  z-index: 2;
}

.control-btn {
  position: absolute;
  width: 56px;
  height: 56px;
  border-radius: 14px;
  border: 1px solid rgba(196, 184, 165, 0.25);
  background: rgba(26, 24, 22, 0.55);
  color: var(--text-mid);
  font-family: 'IBM Plex Mono', monospace;
  font-size: 1.2rem;
  cursor: pointer;
  transition: transform 0.12s ease, border-color 0.25s ease, color 0.25s ease, background 0.25s ease;
  box-shadow: 0 10px 22px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.04);
}

.control-btn:hover {
  transform: translateY(-1px);
  border-color: rgba(231, 223, 207, 0.25);
  color: var(--text-bright);
  background: rgba(26, 24, 22, 0.70);
}

.control-btn:active { transform: translateY(0); }

.control-btn:nth-child(1) { left: 62px; top: 0; }
.control-btn:nth-child(2) { left: 0; top: 62px; }
.control-btn:nth-child(3) { right: 0; top: 62px; }
.control-btn:nth-child(4) { left: 62px; bottom: 0; }

/* Modal + audio init share styles */
#modal,
#audio-init {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  padding: 1rem;
  z-index: 2000;
  background: rgba(20, 18, 16, 0.90);
}

#modal.active { display: flex; }
#audio-init { display: flex; z-index: 3000; }
#audio-init.hidden { display: none; }

.modal-content {
  width: min(92vw, 520px);
  padding: 1.75rem 1.5rem;
  background: rgba(26, 24, 22, 0.82);
  border: 1px solid rgba(196, 184, 165, 0.22);
  border-radius: 18px;
  box-shadow:
    0 22px 70px rgba(0,0,0,0.55),
    inset 0 1px 0 rgba(255,255,255,0.04);
  animation: fadeIn 0.35s ease-out;
  text-align: center;
}

.modal-title {
  font-family: 'Cormorant Garamond', serif;
  font-weight: 600;
  letter-spacing: 0.12rem;
  font-size: clamp(1.2rem, 3vw, 1.6rem);
  color: var(--paper);
  margin-bottom: 0.65rem;
}

.modal-text {
  color: var(--text-mid);
  font-size: 0.9rem;
  line-height: 1.6;
  margin-bottom: 1.25rem;
}

.modal-buttons {
  display: flex;
  gap: 0.75rem;
  justify-content: center;
  flex-wrap: wrap;
}

/* Any buttons inside modals (including START) */
button,
.modal-buttons button {
  font-family: 'IBM Plex Mono', monospace;
  font-size: 0.8rem;
  letter-spacing: 0.12rem;
  text-transform: lowercase;
  padding: 0.6rem 1.25rem;
  border-radius: 999px;
  border: 1px solid rgba(196, 184, 165, 0.26);
  background: transparent;
  color: var(--text-mid);
  cursor: pointer;
  transition: transform 0.12s ease, border-color 0.25s ease, color 0.25s ease, box-shadow 0.25s ease, background 0.25s ease;
}

button:hover,
.modal-buttons button:hover {
  transform: translateY(-1px);
  border-color: rgba(231, 223, 207, 0.30);
  color: var(--text-bright);
  box-shadow: 0 10px 26px rgba(0,0,0,0.35);
  background: rgba(231, 223, 207, 0.04);
}

button:active,
.modal-buttons button:active { transform: translateY(0); }

/* Glitch effect (kept, but less violent) */
.glitch { animation: glitchShake 0.22s ease-in-out; }

@keyframes glitchShake {
  0%, 100% { transform: translate(0, 0); filter: none; }
  25% { transform: translate(-1px, 1px); filter: saturate(1.05); }
  50% { transform: translate(1px, -1px); filter: saturate(1.08); }
  75% { transform: translate(-1px, -1px); filter: saturate(1.05); }
}

@keyframes playerPulse {
  0%, 100% { filter: brightness(1); box-shadow: 0 0 20px rgba(121, 191, 161, 0.25), 0 0 40px rgba(121, 191, 161, 0.10); }
  50% { filter: brightness(1.1); box-shadow: 0 0 25px rgba(121, 191, 161, 0.35), 0 0 50px rgba(121, 191, 161, 0.15); }
}

@keyframes distortionFlicker {
  0%, 100% { opacity: 0.95; transform: rotate(0deg); }
  25% { opacity: 0.85; transform: rotate(0.5deg); }
  50% { opacity: 0.90; transform: rotate(-0.5deg); }
  75% { opacity: 0.88; transform: rotate(0.3deg); }
}

@keyframes anchorGlow {
  0%, 100% { filter: brightness(1); box-shadow: 0 0 18px rgba(127, 182, 194, 0.22), 0 0 35px rgba(127, 182, 194, 0.08); }
  50% { filter: brightness(1.12); box-shadow: 0 0 22px rgba(127, 182, 194, 0.30), 0 0 45px rgba(127, 182, 194, 0.12); }
}

@keyframes artifactSparkle {
  0%, 100% { filter: brightness(1); box-shadow: 0 0 22px rgba(215, 192, 122, 0.30), 0 0 45px rgba(215, 192, 122, 0.12); }
  50% { filter: brightness(1.15); box-shadow: 0 0 28px rgba(215, 192, 122, 0.45), 0 0 55px rgba(215, 192, 122, 0.18); }
}

@keyframes exitPulse {
  0%, 100% { box-shadow: 0 0 18px rgba(121,191,161,0.18), 0 0 35px rgba(121,191,161,0.08); }
  50% { box-shadow: 0 0 24px rgba(121,191,161,0.28), 0 0 45px rgba(121,191,161,0.12); }
}

@keyframes exitInnerPulse {
  0%, 100% { opacity: 0.5; transform: rotate(45deg) scale(1); }
  50% { opacity: 0.8; transform: rotate(45deg) scale(1.08); }
}

@keyframes textPulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.65; }
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(12px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Responsive: show d-pad on small screens */
@media (max-width: 820px) {
  #mobile-controls { display: block; }
  body { padding: 1rem; }
  #game-container { padding: 1rem; border-radius: 16px; }
  #grid { border-radius: 12px; padding: 0.75rem; }
}
    </style>
</head>
<body>
    <!-- Audio init overlay -->
    <div id="audio-init">
        <div class="modal-content">
            <div class="modal-title">INITIALIZE SIGNAL</div>
            <div class="modal-text">Press to begin transmission</div>
            <button id="init-audio-btn" onclick="initAudio()" autofocus>START</button>
        </div>
    </div>

    <div class="container">
        <header>
            <h1>COHERENCE</h1>
            <div class="subtitle">Signal Decay Protocol</div>
        </header>
        
        <div id="game-container">
            <div id="grid"></div>
            <div id="status">
                <div class="status-line">
                    COH: <span id="coh-value" class="coh-value coh-high">20</span>
                </div>
                <div class="status-line">
                    STATE: <span id="state-value" class="state-stable">STABLE</span>
                </div>
                <div class="status-line">
                    CARRY: <span id="carry-value">NONE</span>
                </div>
            </div>
        </div>
        
        <div id="mobile-controls">
            <button class="control-btn" onclick="movePlayer(0, -1)">↑</button>
            <button class="control-btn" onclick="movePlayer(-1, 0)">←</button>
            <button class="control-btn" onclick="movePlayer(1, 0)">→</button>
            <button class="control-btn" onclick="movePlayer(0, 1)">↓</button>
        </div>
        
        <div class="instructions">
            ARROW KEYS OR WASD TO MOVE • FIND ARTIFACT TO UNLOCK EXIT • ESCAPE BEFORE DISSOLUTION
        </div>
    </div>
    
    <div id="modal">
        <div class="modal-content">
            <div class="modal-title" id="modal-title"></div>
            <div class="modal-text" id="modal-text"></div>
            <div class="modal-buttons" id="modal-buttons"></div>
        </div>
    </div>

    <!-- Audio elements -->
    <audio id="music-main" loop>
        <source src="music/coherence.mp3" type="audio/mpeg">
    </audio>
    <audio id="music-threshold" loop>
        <source src="music/coherence-threshold.mp3" type="audio/mpeg">
    </audio>
    
    <script>
        // Audio system
        const audioMain = document.getElementById('music-main');
        const audioThreshold = document.getElementById('music-threshold');
        let audioInitialized = false;
        let audioContext = null;

        function initAudio() {
            audioMain.volume = 0.5;
            audioThreshold.volume = 0.5;

            // Initialize Web Audio API context for sound effects
            audioContext = new (window.AudioContext || window.webkitAudioContext)();

            audioMain.play().then(() => {
                audioInitialized = true;
                document.getElementById('audio-init').classList.add('hidden');
            }).catch(err => {
                console.log('Audio autoplay prevented:', err);
                audioInitialized = true;
                document.getElementById('audio-init').classList.add('hidden');
            });
        }

        function switchToThresholdMusic() {
            if (!audioInitialized) return;
            audioMain.pause();
            audioThreshold.play().catch(err => console.log('Threshold music error:', err));
        }

        // Procedural sound effects using Web Audio API
        function playSound(type) {
            if (!audioContext) return;

            const now = audioContext.currentTime;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            switch(type) {
                case 'move':
                    // Soft blip for movement
                    oscillator.frequency.setValueAtTime(200, now);
                    oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.05);
                    gainNode.gain.setValueAtTime(0.1, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                    oscillator.start(now);
                    oscillator.stop(now + 0.05);
                    break;

                case 'artifact':
                    // Ascending chime for artifact pickup
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(400, now);
                    oscillator.frequency.exponentialRampToValueAtTime(800, now + 0.1);
                    oscillator.frequency.exponentialRampToValueAtTime(1200, now + 0.2);
                    gainNode.gain.setValueAtTime(0.2, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    oscillator.start(now);
                    oscillator.stop(now + 0.3);
                    break;

                case 'anchor':
                    // Warm restoration tone
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(300, now);
                    oscillator.frequency.setValueAtTime(400, now + 0.05);
                    oscillator.frequency.setValueAtTime(500, now + 0.1);
                    gainNode.gain.setValueAtTime(0.15, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    oscillator.start(now);
                    oscillator.stop(now + 0.2);
                    break;

                case 'distortion':
                    // Harsh digital noise for distortion damage
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(150, now);
                    oscillator.frequency.exponentialRampToValueAtTime(80, now + 0.15);
                    gainNode.gain.setValueAtTime(0.08, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    oscillator.start(now);
                    oscillator.stop(now + 0.15);
                    break;

                case 'threshold':
                    // Ominous low tone for crossing threshold
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(100, now);
                    oscillator.frequency.exponentialRampToValueAtTime(60, now + 0.4);
                    gainNode.gain.setValueAtTime(0.2, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                    oscillator.start(now);
                    oscillator.stop(now + 0.4);
                    break;

                case 'collision':
                    // Sharp hit for wall collision
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(100, now);
                    gainNode.gain.setValueAtTime(0.15, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                    oscillator.start(now);
                    oscillator.stop(now + 0.08);
                    break;

                case 'exit':
                    // Victory fanfare
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(500, now);
                    oscillator.frequency.setValueAtTime(600, now + 0.1);
                    oscillator.frequency.setValueAtTime(800, now + 0.2);
                    oscillator.frequency.setValueAtTime(1000, now + 0.3);
                    gainNode.gain.setValueAtTime(0.2, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    oscillator.start(now);
                    oscillator.stop(now + 0.5);
                    break;

                case 'death':
                    // Descending failure tone
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(300, now);
                    oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.5);
                    gainNode.gain.setValueAtTime(0.2, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    oscillator.start(now);
                    oscillator.stop(now + 0.5);
                    break;
            }
        }

        // Game State
        const gameState = {
            grid: [],
            playerPos: { x: 1, y: 1 },
            coherence: 20,
            belowThreshold: false,
            turnCounter: 0,
            carriedArtifact: null,
            gameOver: false,
            won: false,
            anchorUsed: false,
            thresholdRow: 5,
            hasArtifact: false // New: track if player has collected an artifact
        };
        
        // Artifact definitions
        const artifacts = [
            {
                name: "RESONANCE INVERTER",
                description: "Distortions become Anchors. Anchors become Distortions.",
                cohBonus: 6,
                effect: "invert"
            },
            {
                name: "CLARITY LENS",
                description: "See the pattern, pay the price. +1 drain per turn.",
                cohBonus: 6,
                effect: "clarity"
            },
            {
                name: "SEVERANCE",
                description: "Immune to distortion adjacency. Anchors no longer function.",
                cohBonus: 6,
                effect: "sever"
            },
            {
                name: "TEMPORAL ECHO",
                description: "Every 5th move is free. Time bends around you.",
                cohBonus: 8,
                effect: "echo"
            },
            {
                name: "VOID COMPASS",
                description: "Distortions spread slower. Coherence drain reduced by 1.",
                cohBonus: 5,
                effect: "compass"
            },
            {
                name: "HARMONIC BEACON",
                description: "Anchors restore +15 instead of +10. Attracts distortion faster.",
                cohBonus: 4,
                effect: "beacon"
            }
        ];
        
        // Generate random level
        function generateLevel() {
            const width = 16;
            const height = 16;
            const grid = [];

            // Initialize with boundaries and ground
            for (let y = 0; y < height; y++) {
                grid[y] = [];
                for (let x = 0; x < width; x++) {
                    if (y === 0 || y === height - 1 || x === 0 || x === width - 1) {
                        grid[y][x] = '#'; // Boundary
                    } else {
                        grid[y][x] = '.'; // Ground
                    }
                }
            }

            // Place threshold near middle (row 8 in 16x16 grid)
            const thresholdRow = 8;
            gameState.thresholdRow = thresholdRow;
            for (let x = 1; x < width - 1; x++) {
                grid[thresholdRow][x] = '+';
            }

            // Place player in top-left area (above threshold)
            gameState.playerPos = { x: 1, y: 1 };

            // Place exit in top-right area (above threshold)
            grid[1][width - 2] = 'X';

            // Place 1 artifact above threshold
            const aboveY = Math.floor(Math.random() * (thresholdRow - 2)) + 2; // rows 2-7
            const aboveX = Math.floor(Math.random() * (width - 4)) + 2; // avoid edges
            grid[aboveY][aboveX] = '*';

            // Place 3 artifacts below threshold
            const belowArtifacts = [];
            for (let i = 0; i < 3; i++) {
                let x, y;
                do {
                    y = Math.floor(Math.random() * (height - thresholdRow - 3)) + thresholdRow + 1; // rows 9-14
                    x = Math.floor(Math.random() * (width - 4)) + 2;
                } while (grid[y][x] !== '.' || belowArtifacts.some(a => a.x === x && a.y === y));

                grid[y][x] = '*';
                belowArtifacts.push({ x, y });
            }

            // Place 2-3 anchors below threshold (more anchors for larger grid)
            const anchorCount = Math.floor(Math.random() * 2) + 2; // 2 or 3
            for (let i = 0; i < anchorCount; i++) {
                let x, y;
                do {
                    y = Math.floor(Math.random() * (height - thresholdRow - 3)) + thresholdRow + 1;
                    x = Math.floor(Math.random() * (width - 4)) + 2;
                } while (grid[y][x] !== '.');

                grid[y][x] = 'O';
            }

            // Place 4-6 initial distortions scattered throughout (more for larger grid)
            const distortionCount = Math.floor(Math.random() * 3) + 4; // 4 to 6
            for (let i = 0; i < distortionCount; i++) {
                let x, y;
                do {
                    y = Math.floor(Math.random() * (height - 4)) + 2; // rows 2-14
                    x = Math.floor(Math.random() * (width - 4)) + 2;
                } while (grid[y][x] !== '.' || (y === thresholdRow));

                grid[y][x] = '~';
            }

            return grid;
        }

        // Initialize game
        function initGame() {
            gameState.grid = generateLevel();
            renderGrid();
            updateStatus();
        }
        
        // Render the grid
        function renderGrid() {
            const gridElement = document.getElementById('grid');
            gridElement.innerHTML = '';
            
            for (let y = 0; y < gameState.grid.length; y++) {
                for (let x = 0; x < gameState.grid[y].length; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    
                    let tile = gameState.grid[y][x];
                    
                    // Player position
                    if (x === gameState.playerPos.x && y === gameState.playerPos.y) {
                        cell.classList.add('player');
                    } else {
                        // Apply classes based on tile type
                        switch(tile) {
                            case '.': cell.classList.add('ground'); break;
                            case '#': cell.classList.add('boundary'); break;
                            case '~': cell.classList.add('distortion'); break;
                            case 'O': cell.classList.add('anchor'); break;
                            case '+': cell.classList.add('threshold'); break;
                            case '*': cell.classList.add('artifact'); break;
                            case 'X': cell.classList.add('exit'); break;
                        }
                    }
                    
                    gridElement.appendChild(cell);
                }
            }
        }
        
        // Update status line
        function updateStatus() {
            const cohValue = document.getElementById('coh-value');
            const stateValue = document.getElementById('state-value');
            const carryValue = document.getElementById('carry-value');
            
            // Update coherence
            cohValue.textContent = gameState.coherence;
            cohValue.className = 'coh-value';
            if (gameState.coherence >= 15) {
                cohValue.classList.add('coh-high');
            } else if (gameState.coherence >= 8) {
                cohValue.classList.add('coh-medium');
            } else {
                cohValue.classList.add('coh-low');
            }
            
            // Update state
            let state = 'STABLE';
            let stateClass = 'state-stable';
            
            if (gameState.coherence < 5) {
                state = 'CRITICAL';
                stateClass = 'state-critical';
            } else if (gameState.carriedArtifact) {
                state = 'ALTERED';
                stateClass = 'state-altered';
            } else if (gameState.belowThreshold) {
                state = 'SEARCHING';
                stateClass = 'state-searching';
            }
            
            stateValue.textContent = state;
            stateValue.className = stateClass;
            
            // Update carried item
            carryValue.textContent = gameState.carriedArtifact ? gameState.carriedArtifact.name : 'NONE';
        }
        
        // Handle movement
        function movePlayer(dx, dy) {
            if (gameState.gameOver) return;
            
            const newX = gameState.playerPos.x + dx;
            const newY = gameState.playerPos.y + dy;
            
            // Check boundaries
            if (gameState.grid[newY][newX] === '#') {
                // Glitch effect on collision
                playSound('collision');
                document.getElementById('grid').classList.add('glitch');
                setTimeout(() => {
                    document.getElementById('grid').classList.remove('glitch');
                }, 300);
                return;
            }

            // Move player
            gameState.playerPos.x = newX;
            gameState.playerPos.y = newY;

            // Play movement sound
            playSound('move');

            // Process turn
            processTurn();
        }
        
        // Process a game turn
        function processTurn() {
            gameState.turnCounter++;

            // Base movement cost
            let cohCost = 1;

            // Clarity lens effect: +1 drain per turn
            if (gameState.carriedArtifact && gameState.carriedArtifact.effect === 'clarity') {
                cohCost += 1;
            }

            // Temporal Echo effect: Every 5th move is free
            if (gameState.carriedArtifact && gameState.carriedArtifact.effect === 'echo') {
                if (gameState.turnCounter % 5 === 0) {
                    cohCost = 0;
                }
            }

            gameState.coherence -= cohCost;
            
            // Check current tile
            const currentTile = gameState.grid[gameState.playerPos.y][gameState.playerPos.x];
            
            // Exit check - REQUIRES ARTIFACT
            if (currentTile === 'X') {
                if (!gameState.hasArtifact) {
                    showMessage('EXIT LOCKED', 'ARTIFACT REQUIRED TO UNLOCK TRANSMISSION', false);
                    return;
                }
                winGame();
                return;
            }
            
            // Anchor check
            if (currentTile === 'O' && !gameState.anchorUsed) {
                if (!gameState.carriedArtifact || gameState.carriedArtifact.effect !== 'sever') {
                    const invert = gameState.carriedArtifact && gameState.carriedArtifact.effect === 'invert';
                    if (!invert) {
                        // Harmonic Beacon: +15 instead of +10
                        const anchorBonus = (gameState.carriedArtifact && gameState.carriedArtifact.effect === 'beacon') ? 15 : 10;
                        gameState.coherence += anchorBonus;
                        gameState.grid[gameState.playerPos.y][gameState.playerPos.x] = '.';
                        playSound('anchor');
                        // No pop-up, just apply the effect silently
                    }
                }
                // Severance: anchor doesn't work (no message)
            }
            
            // Artifact pickup check
            if (currentTile === '*') {
                handleArtifactPickup();
                return;
            }
            
            // Threshold crossing check
            if (currentTile === '+' && !gameState.belowThreshold) {
                gameState.belowThreshold = true;
                playSound('threshold');
                switchToThresholdMusic();
                // No pop-up, just switch music and activate distortion spreading
            }
            
            // Distortion adjacency/standing check
            checkDistortionDrain();
            
            // Post-threshold spreading
            if (gameState.belowThreshold && gameState.turnCounter % 3 === 0) {
                spreadDistortions();
            }
            
            // Coherence check
            if (gameState.coherence <= 0) {
                loseGame();
                return;
            }
            
            renderGrid();
            updateStatus();
        }
        
        // Check for distortion drain
        function checkDistortionDrain() {
            const px = gameState.playerPos.x;
            const py = gameState.playerPos.y;
            const currentTile = gameState.grid[py][px];

            // If carrying severance artifact, immune to distortion
            if (gameState.carriedArtifact && gameState.carriedArtifact.effect === 'sever') {
                return;
            }

            const invert = gameState.carriedArtifact && gameState.carriedArtifact.effect === 'invert';
            const hasCompass = gameState.carriedArtifact && gameState.carriedArtifact.effect === 'compass';

            // Standing on distortion
            if (currentTile === '~') {
                let drain = 2;
                // Void Compass: reduce drain by 1
                if (hasCompass && !invert) {
                    drain = 1;
                }

                if (!invert) {
                    gameState.coherence -= drain;
                    playSound('distortion');
                } else {
                    gameState.coherence += 2; // Inverted: distortion heals
                }
                return;
            }

            // Check adjacent tiles (cardinal only)
            const adjacent = [
                {x: px-1, y: py},
                {x: px+1, y: py},
                {x: px, y: py-1},
                {x: px, y: py+1}
            ];

            for (let pos of adjacent) {
                if (pos.y >= 0 && pos.y < gameState.grid.length &&
                    pos.x >= 0 && pos.x < gameState.grid[pos.y].length) {
                    if (gameState.grid[pos.y][pos.x] === '~') {
                        let drain = 1;
                        // Void Compass: reduce drain by 1 (to 0 for adjacency)
                        if (hasCompass && !invert) {
                            drain = 0;
                        }

                        if (!invert) {
                            gameState.coherence -= drain;
                        } else {
                            gameState.coherence += 1; // Inverted: adjacency heals
                        }
                        return; // Only drain once even if multiple adjacent
                    }
                }
            }
        }
        
        // Count how many distortion neighbors a tile has
        function countDistortedNeighbors(x, y) {
            let count = 0;
            const neighbors = [
                {x: x - 1, y: y},
                {x: x + 1, y: y},
                {x: x, y: y - 1},
                {x: x, y: y + 1}
            ];

            for (let pos of neighbors) {
                if (pos.y >= 0 && pos.y < gameState.grid.length &&
                    pos.x >= 0 && pos.x < gameState.grid[pos.y].length) {
                    if (gameState.grid[pos.y][pos.x] === '~') {
                        count++;
                    }
                }
            }

            return count;
        }

        // Spread distortions using "Coral Growth" algorithm
        function spreadDistortions() {
            // Get spread rate based on artifacts
            let spreadCount = 1; // Default: one spread per cycle

            // Harmonic Beacon: distortions spread faster (2 per cycle)
            if (gameState.carriedArtifact && gameState.carriedArtifact.effect === 'beacon') {
                spreadCount = 2;
            }

            // Void Compass: distortions spread slower (1 every 2 cycles)
            if (gameState.carriedArtifact && gameState.carriedArtifact.effect === 'compass') {
                if (gameState.turnCounter % 6 !== 0) {
                    return; // Skip spreading this cycle
                }
            }

            // Find all potential growth candidates
            const candidates = [];

            for (let y = 0; y < gameState.grid.length; y++) {
                for (let x = 0; x < gameState.grid[y].length; x++) {
                    if (gameState.grid[y][x] === '~') {
                        // Check all neighbors of this distortion
                        const neighbors = [
                            {x: x - 1, y: y},
                            {x: x + 1, y: y},
                            {x: x, y: y - 1},
                            {x: x, y: y + 1}
                        ];

                        for (let neighbor of neighbors) {
                            const nx = neighbor.x;
                            const ny = neighbor.y;

                            // Check if neighbor is valid and empty
                            if (ny >= 0 && ny < gameState.grid.length &&
                                nx >= 0 && nx < gameState.grid[ny].length &&
                                gameState.grid[ny][nx] === '.') {

                                // Apply Coral Growth Rule: only allow spread if target has < 2 distortion neighbors
                                const neighborCount = countDistortedNeighbors(nx, ny);

                                if (neighborCount < 2) {
                                    // This preserves navigable paths
                                    candidates.push({x: nx, y: ny, neighborCount: neighborCount});
                                }
                            }
                        }
                    }
                }
            }

            // Execute spreads (one or more based on artifact effects)
            for (let i = 0; i < spreadCount && candidates.length > 0; i++) {
                // Pick a random valid candidate
                const chosenIndex = Math.floor(Math.random() * candidates.length);
                const chosen = candidates[chosenIndex];

                gameState.grid[chosen.y][chosen.x] = '~';

                // Remove this candidate to avoid duplicate spreads
                candidates.splice(chosenIndex, 1);
            }
        }
        
        // Handle artifact pickup
        function handleArtifactPickup() {
            // Pick random artifact
            const artifact = artifacts[Math.floor(Math.random() * artifacts.length)];
            
            showArtifactPrompt(artifact);
        }
        
        // Show artifact pickup prompt
        function showArtifactPrompt(artifact) {
            const modal = document.getElementById('modal');
            const title = document.getElementById('modal-title');
            const text = document.getElementById('modal-text');
            const buttons = document.getElementById('modal-buttons');

            title.textContent = `ARTIFACT: ${artifact.name}`;
            text.innerHTML = `
                ${artifact.description}<br><br>
                <strong>IMMEDIATE: +${artifact.cohBonus} COHERENCE</strong>
            `;

            let buttonHTML = '';

            // If player already has an artifact, show only trade/decline options
            if (gameState.carriedArtifact) {
                buttonHTML = `<button class="danger" onclick="tradeArtifact(${artifacts.indexOf(artifact)})" id="modal-primary-btn">TRADE</button>`;
                buttonHTML += `<button class="secondary" onclick="declineArtifact()" id="modal-secondary-btn">DECLINE</button>`;
            } else {
                // First artifact: show accept/decline
                buttonHTML = `<button onclick="acceptArtifact(${artifacts.indexOf(artifact)})" id="modal-primary-btn">ACCEPT</button>`;
                buttonHTML += `<button class="secondary" onclick="declineArtifact()" id="modal-secondary-btn">DECLINE</button>`;
            }

            buttons.innerHTML = buttonHTML;
            modal.classList.add('active');

            // Focus first button
            setTimeout(() => {
                document.getElementById('modal-primary-btn').focus();
            }, 100);
        }
        
        // Accept artifact
        function acceptArtifact(index) {
            const artifact = artifacts[index];

            if (gameState.carriedArtifact) {
                // Can't accept if already carrying
                return;
            }

            gameState.carriedArtifact = artifact;
            gameState.hasArtifact = true; // Mark that player has collected an artifact
            gameState.coherence += artifact.cohBonus;
            gameState.grid[gameState.playerPos.y][gameState.playerPos.x] = '.';

            playSound('artifact');
            document.getElementById('modal').classList.remove('active');

            renderGrid();
            updateStatus();
        }

        // Trade artifact
        function tradeArtifact(index) {
            const newArtifact = artifacts[index];
            gameState.carriedArtifact = newArtifact;
            gameState.coherence += newArtifact.cohBonus;
            gameState.grid[gameState.playerPos.y][gameState.playerPos.x] = '.';

            playSound('artifact');
            document.getElementById('modal').classList.remove('active');

            renderGrid();
            updateStatus();
        }

        // Decline artifact
        function declineArtifact() {
            document.getElementById('modal').classList.remove('active');
            renderGrid();
            updateStatus();
        }
        
        // Show message modal
        function showMessage(title, message, isGameEnd) {
            const modal = document.getElementById('modal');
            const titleEl = document.getElementById('modal-title');
            const text = document.getElementById('modal-text');
            const buttons = document.getElementById('modal-buttons');
            
            titleEl.textContent = title;
            text.textContent = message;
            
            if (isGameEnd) {
                buttons.innerHTML = '<button onclick="location.reload()" id="modal-primary-btn">RESET SIGNAL</button>';
            } else {
                buttons.innerHTML = '<button onclick="closeMessage()" id="modal-primary-btn">CONTINUE</button>';
            }
            
            modal.classList.add('active');
            
            // Focus button
            setTimeout(() => {
                document.getElementById('modal-primary-btn').focus();
            }, 100);
        }
        
        // Close message
        function closeMessage() {
            document.getElementById('modal').classList.remove('active');
        }
        
        // Win game
        function winGame() {
            gameState.gameOver = true;
            gameState.won = true;

            playSound('exit');

            let message = '';
            if (gameState.coherence >= 15) {
                message = 'YOU EMERGED WHOLE • SIGNAL PRESERVED';
            } else if (gameState.coherence >= 8) {
                message = 'YOU MADE IT OUT, BARELY • FRAGMENTS REMAIN';
            } else {
                message = 'YOU ESCAPED WITH FRAGMENTS • BARELY COHERENT';
            }

            showMessage('TRANSMISSION COMPLETE', message, true);
        }

        // Lose game
        function loseGame() {
            gameState.gameOver = true;
            playSound('death');
            showMessage('SIGNAL LOST', 'DISSOLUTION • COHERENCE COLLAPSED', true);
        }
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            // Check if audio init screen is active
            const audioInitActive = !document.getElementById('audio-init').classList.contains('hidden');

            if (audioInitActive) {
                // Handle Enter or Space key on audio init screen
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    initAudio();
                }
                return;
            }

            if (gameState.gameOver) return;

            // Check if modal is active
            const modalActive = document.getElementById('modal').classList.contains('active');

            if (modalActive) {
                // Get all buttons in the modal
                const buttons = document.getElementById('modal-buttons').querySelectorAll('button');
                const focusedElement = document.activeElement;
                let currentIndex = Array.from(buttons).indexOf(focusedElement);

                // Handle Enter key in modals - click focused button
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    if (focusedElement && focusedElement.tagName === 'BUTTON') {
                        focusedElement.click();
                    } else if (buttons.length > 0) {
                        buttons[0].click();
                    }
                    return;
                }

                // Handle arrow keys and WASD for navigation
                if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A' ||
                    e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
                    e.preventDefault();
                    if (currentIndex === -1) currentIndex = 0;
                    else currentIndex = (currentIndex - 1 + buttons.length) % buttons.length;
                    buttons[currentIndex].focus();
                    return;
                }

                if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D' ||
                    e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
                    e.preventDefault();
                    if (currentIndex === -1) currentIndex = 0;
                    else currentIndex = (currentIndex + 1) % buttons.length;
                    buttons[currentIndex].focus();
                    return;
                }

                return;
            }
            
            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    e.preventDefault();
                    movePlayer(0, -1);
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    e.preventDefault();
                    movePlayer(0, 1);
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    e.preventDefault();
                    movePlayer(-1, 0);
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    e.preventDefault();
                    movePlayer(1, 0);
                    break;
            }
        });
        
        // Initialize on load
        initGame();
    </script>
</body>
</html>
