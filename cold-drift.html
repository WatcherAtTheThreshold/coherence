<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COLD DRIFT</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&family=Cormorant+Garamond:wght@400;600&display=swap');

        :root {
            --void: #1a1a2e;
            --earth-deep: #16213e;
            --snow-white: #f0f4f8;
            --snow-shadow: #c8d6e5;
            --trail-brown: #8b7355;
            --driveway-grey: #4a5568;
            --border-dark: #2d3748;
            --text-dim: #6b7b8a;
            --text-bright: #e2e8f0;
            --accent-cold: #74b9ff;
            --accent-warm: #fd9644;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'IBM Plex Mono', monospace;
            background: linear-gradient(180deg, var(--void) 0%, var(--earth-deep) 100%);
            color: var(--text-bright);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            overflow: hidden;
        }

        .container {
            text-align: center;
            max-width: 100%;
        }

        header {
            margin-bottom: 1rem;
            animation: fadeIn 1.5s ease-out;
        }

        h1 {
            font-family: 'Cormorant Garamond', serif;
            font-size: clamp(1.8rem, 4vw, 2.5rem);
            font-weight: 400;
            letter-spacing: 0.4rem;
            text-transform: uppercase;
            color: var(--snow-white);
            text-shadow: 0 2px 10px rgba(116, 185, 255, 0.3);
        }

        .subtitle {
            font-size: clamp(0.65rem, 1.5vw, 0.8rem);
            color: var(--text-dim);
            letter-spacing: 0.2rem;
            text-transform: lowercase;
            font-style: italic;
            margin-top: 0.3rem;
        }

        #game-container {
            display: inline-block;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(116, 185, 255, 0.2);
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
        }

        canvas {
            display: block;
            border-radius: 4px;
            image-rendering: pixelated;
        }

        #status {
            margin-top: 0.75rem;
            font-size: clamp(0.7rem, 1.5vw, 0.85rem);
            color: var(--text-dim);
            letter-spacing: 0.15rem;
        }

        #status span {
            color: var(--accent-cold);
            font-weight: 600;
        }

        .instructions {
            margin-top: 0.75rem;
            font-size: clamp(0.6rem, 1.3vw, 0.72rem);
            color: var(--text-dim);
            letter-spacing: 0.1rem;
            font-style: italic;
        }

        /* Audio init overlay */
        #audio-init {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, var(--void) 0%, var(--earth-deep) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            transition: opacity 1s ease;
        }

        #audio-init.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .init-content {
            text-align: center;
            padding: 2rem;
        }

        .init-content h2 {
            font-family: 'Cormorant Garamond', serif;
            font-size: clamp(2rem, 5vw, 3rem);
            font-weight: 400;
            letter-spacing: 0.4rem;
            color: var(--snow-white);
            margin-bottom: 0.5rem;
            text-shadow: 0 4px 20px rgba(116, 185, 255, 0.4);
        }

        .init-content p {
            font-size: 0.85rem;
            color: var(--text-dim);
            margin-bottom: 1.5rem;
            font-style: italic;
            letter-spacing: 0.1rem;
        }

        .init-content button {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9rem;
            padding: 0.75rem 2.5rem;
            background: transparent;
            border: 1px solid var(--accent-cold);
            color: var(--accent-cold);
            cursor: pointer;
            transition: all 0.4s ease;
            text-transform: lowercase;
            letter-spacing: 0.2rem;
            border-radius: 4px;
        }

        .init-content button:hover {
            background: var(--accent-cold);
            color: var(--void);
            box-shadow: 0 4px 20px rgba(116, 185, 255, 0.4);
        }

        /* Snowflake particles in background */
        .snowflake {
            position: fixed;
            color: rgba(255, 255, 255, 0.6);
            font-size: 1rem;
            pointer-events: none;
            animation: fall linear infinite;
            z-index: 1;
        }

        @keyframes fall {
            0% {
                transform: translateY(-10vh) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 600px) {
            body {
                padding: 0.5rem;
            }
            #game-container {
                padding: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <!-- Audio init overlay -->
    <div id="audio-init">
        <div class="init-content">
            <h2>Cold Drift</h2>
            <p>keep the paths clear</p>
            <button onclick="initGame()" autofocus>begin shoveling</button>
        </div>
    </div>

    <div class="container">
        <header>
            <h1>Cold Drift</h1>
            <div class="subtitle">a shoveling meditation</div>
        </header>

        <div id="game-container">
            <canvas id="canvas"></canvas>
        </div>

        <div id="status">
            cleared: <span id="cleared-count">0</span> |
            rescued: <span id="rescued-count">0</span> |
            wizards: <span id="wizard-count">0</span>
        </div>

        <div class="instructions">
            wasd or arrows to move and shovel • clear the paths • rescue buried friends
        </div>
    </div>

    <audio id="music" loop>
        <source src="music/stroll.mp3" type="audio/mpeg">
    </audio>

    <script>
        // ============================================
        // CONSTANTS
        // ============================================
        const GRID_SIZE = 24;
        const TILE_SIZE = 20;
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Tile types
        const TILE = {
            BORDER: 0,
            TRAIL: 1,
            DRIVEWAY: 2,
            GRASS: 3
        };

        // Colors
        const COLORS = {
            border: '#2d3748',
            trail: '#8b7355',
            driveway: '#4a5568',
            grass: '#3d5a3d',
            snow: ['#f0f4f8', '#e8eef4', '#dde6f0', '#d0dce8', '#c0d0e0'],
            snowShadow: '#a0b0c0'
        };

        // Elements for wizards
        const ELEMENTS = {
            fire: { color: '#ff6b4a', burst: '#ff9f43', name: 'fire' },
            water: { color: '#54a0ff', burst: '#74b9ff', name: 'water' },
            earth: { color: '#6ab04c', burst: '#78e08f', name: 'earth' },
            air: { color: '#a0a0c0', burst: '#d0d0e0', name: 'air' },
            electric: { color: '#f9ca24', burst: '#ffeaa7', name: 'electric' },
            cosmic: { color: '#a070c0', burst: '#6c3483', name: 'cosmic' }
        };

        // ============================================
        // GAME STATE
        // ============================================
        const game = {
            grid: [],           // Base tile types
            snow: [],           // Snow depth per tile (0-5)
            player: { x: 12, y: 12 },
            animals: [],
            wizards: [],
            particles: [],
            burstEffects: [],
            clearedCount: 0,
            rescuedCount: 0,
            wizardCount: 0,
            snowTimer: 0,
            snowInterval: 120,  // Frames between snow falling
            running: false,
            lastTime: 0
        };

        // ============================================
        // AUDIO
        // ============================================
        const music = document.getElementById('music');
        let audioContext = null;

        function initGame() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            music.volume = 0.4;
            music.play().catch(err => console.log('Audio error:', err));

            document.getElementById('audio-init').classList.add('hidden');

            // Set up canvas
            canvas.width = GRID_SIZE * TILE_SIZE;
            canvas.height = GRID_SIZE * TILE_SIZE;

            generateMap();
            game.running = true;
            game.lastTime = performance.now();
            requestAnimationFrame(gameLoop);

            // Create background snowflakes
            createBackgroundSnow();
        }

        function playSound(type) {
            if (!audioContext) return;

            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain);
            gain.connect(audioContext.destination);

            switch(type) {
                case 'shovel':
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(150, now);
                    osc.frequency.exponentialRampToValueAtTime(80, now + 0.08);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                    osc.start(now);
                    osc.stop(now + 0.08);
                    break;

                case 'rescue':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.setValueAtTime(500, now + 0.1);
                    osc.frequency.setValueAtTime(600, now + 0.2);
                    osc.frequency.setValueAtTime(800, now + 0.3);
                    gain.gain.setValueAtTime(0.15, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                    osc.start(now);
                    osc.stop(now + 0.4);
                    break;

                case 'wizard':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(300, now);
                    osc.frequency.exponentialRampToValueAtTime(600, now + 0.15);
                    osc.frequency.exponentialRampToValueAtTime(200, now + 0.3);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
                    osc.start(now);
                    osc.stop(now + 0.35);
                    break;

                case 'step':
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(100 + Math.random() * 50, now);
                    gain.gain.setValueAtTime(0.03, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                    osc.start(now);
                    osc.stop(now + 0.05);
                    break;
            }
        }

        // ============================================
        // MAP GENERATION
        // ============================================
        function generateMap() {
            // Initialize grids
            game.grid = [];
            game.snow = [];

            for (let y = 0; y < GRID_SIZE; y++) {
                game.grid[y] = [];
                game.snow[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    // Border
                    if (x === 0 || x === GRID_SIZE - 1 || y === 0 || y === GRID_SIZE - 1) {
                        game.grid[y][x] = TILE.BORDER;
                        game.snow[y][x] = 0;
                    } else {
                        game.grid[y][x] = TILE.GRASS;
                        game.snow[y][x] = 3 + Math.floor(Math.random() * 2); // Start with snow
                    }
                }
            }

            // Create main pathways (driveways and trails)
            createPathways();

            // Place player at a clear spot
            placePlayer();

            // Place buried animals and wizards
            placeHiddenEntities();
        }

        function createPathways() {
            // Main horizontal driveway through middle
            const driveY = 12;
            for (let x = 1; x < GRID_SIZE - 1; x++) {
                game.grid[driveY][x] = TILE.DRIVEWAY;
                game.grid[driveY - 1][x] = TILE.DRIVEWAY;
            }

            // Vertical driveway on left side
            for (let y = 1; y < GRID_SIZE - 1; y++) {
                game.grid[y][4] = TILE.DRIVEWAY;
                game.grid[y][5] = TILE.DRIVEWAY;
            }

            // Create some trail paths (brown)
            // Trail from top
            for (let y = 1; y < 11; y++) {
                game.grid[y][15] = TILE.TRAIL;
            }

            // Trail branching right
            for (let x = 15; x < 22; x++) {
                game.grid[6][x] = TILE.TRAIL;
            }

            // Trail to bottom right area
            for (let y = 13; y < GRID_SIZE - 1; y++) {
                game.grid[y][20] = TILE.TRAIL;
            }

            // Small garden path
            for (let x = 6; x < 12; x++) {
                game.grid[18][x] = TILE.TRAIL;
            }
            for (let y = 14; y < 19; y++) {
                game.grid[y][10] = TILE.TRAIL;
            }

            // Add some inner border walls/hedges
            // Top left yard
            for (let x = 1; x < 4; x++) {
                game.grid[8][x] = TILE.BORDER;
            }

            // Bottom right yard
            for (let x = 21; x < 23; x++) {
                game.grid[16][x] = TILE.BORDER;
            }
            for (let y = 16; y < 20; y++) {
                game.grid[y][21] = TILE.BORDER;
            }
        }

        function placePlayer() {
            // Find a driveway or trail tile near center
            for (let y = 10; y < 14; y++) {
                for (let x = 6; x < 18; x++) {
                    if (game.grid[y][x] === TILE.DRIVEWAY || game.grid[y][x] === TILE.TRAIL) {
                        game.player.x = x;
                        game.player.y = y;
                        game.snow[y][x] = 0; // Clear starting position
                        return;
                    }
                }
            }
        }

        function placeHiddenEntities() {
            game.animals = [];
            game.wizards = [];

            const elementKeys = Object.keys(ELEMENTS);

            // Place 4-6 animals on paths
            const animalCount = 4 + Math.floor(Math.random() * 3);
            for (let i = 0; i < animalCount; i++) {
                let attempts = 0;
                while (attempts < 50) {
                    const x = 2 + Math.floor(Math.random() * (GRID_SIZE - 4));
                    const y = 2 + Math.floor(Math.random() * (GRID_SIZE - 4));

                    if ((game.grid[y][x] === TILE.TRAIL || game.grid[y][x] === TILE.DRIVEWAY) &&
                        game.snow[y][x] >= 2 &&
                        !hasEntityAt(x, y)) {
                        game.animals.push({
                            x: x,
                            y: y,
                            type: ['rabbit', 'squirrel', 'bird', 'cat'][Math.floor(Math.random() * 4)],
                            revealed: false,
                            fleeing: false,
                            fleeX: 0,
                            fleeY: 0,
                            fleeTimer: 0
                        });
                        break;
                    }
                    attempts++;
                }
            }

            // Place 3-4 wizards
            const wizardCount = 3 + Math.floor(Math.random() * 2);
            for (let i = 0; i < wizardCount; i++) {
                let attempts = 0;
                while (attempts < 50) {
                    const x = 2 + Math.floor(Math.random() * (GRID_SIZE - 4));
                    const y = 2 + Math.floor(Math.random() * (GRID_SIZE - 4));

                    if (game.grid[y][x] !== TILE.BORDER &&
                        game.snow[y][x] >= 2 &&
                        !hasEntityAt(x, y)) {
                        game.wizards.push({
                            x: x,
                            y: y,
                            element: elementKeys[Math.floor(Math.random() * elementKeys.length)],
                            revealed: false,
                            activated: false,
                            fadeTimer: 0
                        });
                        break;
                    }
                    attempts++;
                }
            }
        }

        function hasEntityAt(x, y) {
            if (game.player.x === x && game.player.y === y) return true;
            for (const animal of game.animals) {
                if (animal.x === x && animal.y === y) return true;
            }
            for (const wizard of game.wizards) {
                if (wizard.x === x && wizard.y === y) return true;
            }
            return false;
        }

        // ============================================
        // PLAYER MOVEMENT & SHOVELING
        // ============================================
        function movePlayer(dx, dy) {
            const newX = game.player.x + dx;
            const newY = game.player.y + dy;

            // Check bounds
            if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) return;

            // Check if hitting border
            if (game.grid[newY][newX] === TILE.BORDER) return;

            // Move player
            game.player.x = newX;
            game.player.y = newY;

            // Shovel snow at new position
            if (game.snow[newY][newX] > 0) {
                shovelSnow(newX, newY, dx, dy);
            } else {
                playSound('step');
            }

            // Check for revealed entities
            checkEntities(newX, newY);
        }

        function shovelSnow(x, y, dx, dy) {
            const snowAmount = game.snow[y][x];
            game.snow[y][x] = 0;
            game.clearedCount++;

            playSound('shovel');

            // Create snow particles
            for (let i = 0; i < snowAmount * 2; i++) {
                game.particles.push({
                    x: x * TILE_SIZE + TILE_SIZE / 2,
                    y: y * TILE_SIZE + TILE_SIZE / 2,
                    vx: dx * 3 + (Math.random() - 0.5) * 4,
                    vy: dy * 3 + (Math.random() - 0.5) * 4 - 2,
                    life: 30 + Math.random() * 20,
                    size: 2 + Math.random() * 2
                });
            }

            // Push snow - if next tile exists and isn't border
            const pushX = x + dx;
            const pushY = y + dy;

            if (pushX >= 0 && pushX < GRID_SIZE && pushY >= 0 && pushY < GRID_SIZE) {
                if (game.grid[pushY][pushX] === TILE.BORDER) {
                    // Snow cleared off to border - it's gone!
                } else if (game.snow[pushY][pushX] < 5) {
                    // Add some snow to next tile (but cap it)
                    game.snow[pushY][pushX] = Math.min(5, game.snow[pushY][pushX] + Math.floor(snowAmount / 2));
                }
            }

            updateStatus();
        }

        function checkEntities(x, y) {
            // Check animals
            for (const animal of game.animals) {
                if (animal.x === x && animal.y === y && !animal.revealed && game.snow[y][x] === 0) {
                    animal.revealed = true;
                    playSound('rescue');
                    game.rescuedCount++;
                    updateStatus();

                    // Start fleeing after a moment
                    setTimeout(() => {
                        animal.fleeing = true;
                        // Determine flee direction based on path
                        const path = findPathToEdge(x, y);
                        if (path) {
                            animal.fleePath = path;
                            animal.fleeIndex = 0;
                        }
                    }, 500);
                }
            }

            // Check wizards
            for (const wizard of game.wizards) {
                if (wizard.x === x && wizard.y === y && !wizard.revealed && game.snow[y][x] === 0) {
                    wizard.revealed = true;
                    playSound('wizard');

                    // Activate burst after a moment
                    setTimeout(() => {
                        activateWizardBurst(wizard);
                    }, 300);
                }
            }
        }

        function activateWizardBurst(wizard) {
            wizard.activated = true;
            game.wizardCount++;
            updateStatus();

            const element = ELEMENTS[wizard.element];
            const cx = wizard.x;
            const cy = wizard.y;

            // Create burst effect
            game.burstEffects.push({
                x: cx * TILE_SIZE + TILE_SIZE / 2,
                y: cy * TILE_SIZE + TILE_SIZE / 2,
                color: element.burst,
                radius: 0,
                maxRadius: TILE_SIZE * 3.5,
                life: 60
            });

            // Clear snow in area based on element
            let radius = 3;
            if (wizard.element === 'earth') radius = 2;
            if (wizard.element === 'cosmic') radius = 4;

            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= radius) {
                        const tx = cx + dx;
                        const ty = cy + dy;
                        if (tx >= 0 && tx < GRID_SIZE && ty >= 0 && ty < GRID_SIZE) {
                            if (game.grid[ty][tx] !== TILE.BORDER && game.snow[ty][tx] > 0) {
                                game.snow[ty][tx] = 0;
                                game.clearedCount++;

                                // Create particles
                                for (let i = 0; i < 3; i++) {
                                    game.particles.push({
                                        x: tx * TILE_SIZE + TILE_SIZE / 2,
                                        y: ty * TILE_SIZE + TILE_SIZE / 2,
                                        vx: dx * 0.5 + (Math.random() - 0.5) * 2,
                                        vy: dy * 0.5 + (Math.random() - 0.5) * 2 - 1,
                                        life: 20 + Math.random() * 15,
                                        size: 2 + Math.random() * 2,
                                        color: element.burst
                                    });
                                }
                            }
                        }
                    }
                }
            }

            // Check for newly revealed entities
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const tx = cx + dx;
                    const ty = cy + dy;
                    if (tx >= 0 && tx < GRID_SIZE && ty >= 0 && ty < GRID_SIZE) {
                        checkEntities(tx, ty);
                    }
                }
            }

            // Wizard fades away
            wizard.fadeTimer = 120;
            updateStatus();
        }

        function findPathToEdge(startX, startY) {
            // Simple path finding to nearest edge following paths
            const path = [{x: startX, y: startY}];
            let x = startX;
            let y = startY;
            const visited = new Set();
            visited.add(`${x},${y}`);

            for (let step = 0; step < 30; step++) {
                // Check all directions
                const dirs = [
                    {dx: 0, dy: -1},
                    {dx: 0, dy: 1},
                    {dx: -1, dy: 0},
                    {dx: 1, dy: 0}
                ];

                // Shuffle for variety
                dirs.sort(() => Math.random() - 0.5);

                let moved = false;
                for (const dir of dirs) {
                    const nx = x + dir.dx;
                    const ny = y + dir.dy;
                    const key = `${nx},${ny}`;

                    if (visited.has(key)) continue;

                    // Check if at edge
                    if (nx <= 0 || nx >= GRID_SIZE - 1 || ny <= 0 || ny >= GRID_SIZE - 1) {
                        path.push({x: nx, y: ny});
                        return path;
                    }

                    // Prefer paths
                    if (game.grid[ny][nx] === TILE.TRAIL || game.grid[ny][nx] === TILE.DRIVEWAY) {
                        x = nx;
                        y = ny;
                        path.push({x: x, y: y});
                        visited.add(key);
                        moved = true;
                        break;
                    }
                }

                // If no path found, try any non-border tile
                if (!moved) {
                    for (const dir of dirs) {
                        const nx = x + dir.dx;
                        const ny = y + dir.dy;
                        const key = `${nx},${ny}`;

                        if (visited.has(key)) continue;

                        if (game.grid[ny][nx] !== TILE.BORDER) {
                            x = nx;
                            y = ny;
                            path.push({x: x, y: y});
                            visited.add(key);
                            break;
                        }
                    }
                }
            }

            return path;
        }

        // ============================================
        // SNOW FALLING
        // ============================================
        function snowFall() {
            game.snowTimer++;

            if (game.snowTimer >= game.snowInterval) {
                game.snowTimer = 0;

                // Add snow to random tiles (prefer paths that are clear)
                const snowCount = 2 + Math.floor(Math.random() * 3);
                for (let i = 0; i < snowCount; i++) {
                    const x = 1 + Math.floor(Math.random() * (GRID_SIZE - 2));
                    const y = 1 + Math.floor(Math.random() * (GRID_SIZE - 2));

                    if (game.grid[y][x] !== TILE.BORDER && game.snow[y][x] < 5) {
                        // Slightly more snow on paths (they need clearing!)
                        if (game.grid[y][x] === TILE.TRAIL || game.grid[y][x] === TILE.DRIVEWAY) {
                            game.snow[y][x] = Math.min(5, game.snow[y][x] + 1);
                        } else if (Math.random() < 0.3) {
                            game.snow[y][x] = Math.min(5, game.snow[y][x] + 1);
                        }
                    }
                }
            }
        }

        // ============================================
        // UPDATE
        // ============================================
        function update() {
            snowFall();

            // Update particles
            for (let i = game.particles.length - 1; i >= 0; i--) {
                const p = game.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.15; // gravity
                p.life--;

                if (p.life <= 0) {
                    game.particles.splice(i, 1);
                }
            }

            // Update burst effects
            for (let i = game.burstEffects.length - 1; i >= 0; i--) {
                const b = game.burstEffects[i];
                b.radius += (b.maxRadius - b.radius) * 0.15;
                b.life--;

                if (b.life <= 0) {
                    game.burstEffects.splice(i, 1);
                }
            }

            // Update fleeing animals
            for (const animal of game.animals) {
                if (animal.fleeing && animal.fleePath && animal.fleeIndex < animal.fleePath.length) {
                    animal.fleeTimer++;
                    if (animal.fleeTimer >= 8) {
                        animal.fleeTimer = 0;
                        animal.fleeIndex++;
                        if (animal.fleeIndex < animal.fleePath.length) {
                            animal.x = animal.fleePath[animal.fleeIndex].x;
                            animal.y = animal.fleePath[animal.fleeIndex].y;
                        }
                    }
                }
            }

            // Update wizard fade
            for (const wizard of game.wizards) {
                if (wizard.fadeTimer > 0) {
                    wizard.fadeTimer--;
                }
            }
        }

        // ============================================
        // RENDERING
        // ============================================
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw base tiles
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const px = x * TILE_SIZE;
                    const py = y * TILE_SIZE;

                    // Base tile color
                    switch (game.grid[y][x]) {
                        case TILE.BORDER:
                            ctx.fillStyle = COLORS.border;
                            break;
                        case TILE.TRAIL:
                            ctx.fillStyle = COLORS.trail;
                            break;
                        case TILE.DRIVEWAY:
                            ctx.fillStyle = COLORS.driveway;
                            break;
                        default:
                            ctx.fillStyle = COLORS.grass;
                    }
                    ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);

                    // Draw snow on top
                    const snowDepth = game.snow[y][x];
                    if (snowDepth > 0 && game.grid[y][x] !== TILE.BORDER) {
                        const snowColor = COLORS.snow[Math.min(4, snowDepth - 1)];
                        ctx.fillStyle = snowColor;

                        // Snow covers most of tile with slight edge variation
                        const inset = 1;
                        ctx.fillRect(px + inset, py + inset, TILE_SIZE - inset * 2, TILE_SIZE - inset * 2);

                        // Add snow shadow/depth effect
                        if (snowDepth >= 3) {
                            ctx.fillStyle = COLORS.snowShadow;
                            ctx.globalAlpha = 0.2;
                            ctx.fillRect(px + TILE_SIZE - 4, py + 2, 2, TILE_SIZE - 4);
                            ctx.fillRect(px + 2, py + TILE_SIZE - 4, TILE_SIZE - 4, 2);
                            ctx.globalAlpha = 1;
                        }
                    }
                }
            }

            // Draw burst effects (behind entities)
            for (const burst of game.burstEffects) {
                ctx.beginPath();
                ctx.arc(burst.x, burst.y, burst.radius, 0, Math.PI * 2);
                ctx.fillStyle = burst.color;
                ctx.globalAlpha = burst.life / 60 * 0.4;
                ctx.fill();
                ctx.globalAlpha = 1;
            }

            // Draw hidden entity hints (subtle bumps in snow)
            for (const animal of game.animals) {
                if (!animal.revealed && game.snow[animal.y][animal.x] >= 2) {
                    const px = animal.x * TILE_SIZE + TILE_SIZE / 2;
                    const py = animal.y * TILE_SIZE + TILE_SIZE / 2;
                    ctx.fillStyle = COLORS.snowShadow;
                    ctx.globalAlpha = 0.3;
                    ctx.beginPath();
                    ctx.ellipse(px, py, 4, 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            }

            // Draw revealed animals
            for (const animal of game.animals) {
                if (animal.revealed && animal.fleeIndex < (animal.fleePath?.length || 999)) {
                    drawAnimal(animal);
                }
            }

            // Draw wizards
            for (const wizard of game.wizards) {
                if (wizard.revealed && wizard.fadeTimer > 0) {
                    ctx.globalAlpha = wizard.fadeTimer / 120;
                    drawWizard(wizard);
                    ctx.globalAlpha = 1;
                } else if (wizard.revealed && !wizard.activated) {
                    drawWizard(wizard);
                }
            }

            // Draw player
            drawPlayer();

            // Draw particles
            for (const p of game.particles) {
                ctx.fillStyle = p.color || '#fff';
                ctx.globalAlpha = p.life / 50;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        function drawPlayer() {
            const px = game.player.x * TILE_SIZE + TILE_SIZE / 2;
            const py = game.player.y * TILE_SIZE + TILE_SIZE / 2;
            const s = TILE_SIZE / 20; // Scale factor

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.ellipse(px, py + 8 * s, 6 * s, 3 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Body (winter coat)
            ctx.fillStyle = '#5c7090';
            ctx.fillRect(px - 5 * s, py - 4 * s, 10 * s, 12 * s);

            // Head
            ctx.fillStyle = '#e8c4a0';
            ctx.beginPath();
            ctx.arc(px, py - 6 * s, 5 * s, 0, Math.PI * 2);
            ctx.fill();

            // Winter hat
            ctx.fillStyle = '#c04040';
            ctx.fillRect(px - 5 * s, py - 11 * s, 10 * s, 5 * s);
            ctx.fillStyle = '#e0e0e0';
            ctx.fillRect(px - 6 * s, py - 7 * s, 12 * s, 2 * s);

            // Pom pom
            ctx.fillStyle = '#e0e0e0';
            ctx.beginPath();
            ctx.arc(px, py - 12 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            ctx.fillStyle = '#202020';
            ctx.fillRect(px - 3 * s, py - 7 * s, 2 * s, 2 * s);
            ctx.fillRect(px + 1 * s, py - 7 * s, 2 * s, 2 * s);

            // Shovel
            ctx.fillStyle = '#8b6914';
            ctx.fillRect(px + 6 * s, py - 8 * s, 2 * s, 14 * s);
            ctx.fillStyle = '#606060';
            ctx.fillRect(px + 4 * s, py + 4 * s, 6 * s, 4 * s);
        }

        function drawAnimal(animal) {
            const px = animal.x * TILE_SIZE + TILE_SIZE / 2;
            const py = animal.y * TILE_SIZE + TILE_SIZE / 2;
            const s = TILE_SIZE / 20;

            ctx.save();

            switch (animal.type) {
                case 'rabbit':
                    // Body
                    ctx.fillStyle = '#d0c0b0';
                    ctx.beginPath();
                    ctx.ellipse(px, py + 2 * s, 5 * s, 4 * s, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Head
                    ctx.beginPath();
                    ctx.arc(px + 3 * s, py - 2 * s, 3 * s, 0, Math.PI * 2);
                    ctx.fill();
                    // Ears
                    ctx.fillRect(px + 1 * s, py - 9 * s, 2 * s, 6 * s);
                    ctx.fillRect(px + 4 * s, py - 8 * s, 2 * s, 5 * s);
                    // Eye
                    ctx.fillStyle = '#202020';
                    ctx.beginPath();
                    ctx.arc(px + 4 * s, py - 2 * s, 1 * s, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'squirrel':
                    // Body
                    ctx.fillStyle = '#a07050';
                    ctx.beginPath();
                    ctx.ellipse(px, py + 2 * s, 4 * s, 4 * s, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Tail
                    ctx.beginPath();
                    ctx.ellipse(px - 5 * s, py - 2 * s, 3 * s, 5 * s, -0.5, 0, Math.PI * 2);
                    ctx.fill();
                    // Head
                    ctx.beginPath();
                    ctx.arc(px + 3 * s, py - 1 * s, 3 * s, 0, Math.PI * 2);
                    ctx.fill();
                    // Eye
                    ctx.fillStyle = '#202020';
                    ctx.beginPath();
                    ctx.arc(px + 4 * s, py - 1 * s, 1 * s, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'bird':
                    // Body
                    ctx.fillStyle = '#4080c0';
                    ctx.beginPath();
                    ctx.ellipse(px, py + 2 * s, 4 * s, 3 * s, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Head
                    ctx.beginPath();
                    ctx.arc(px + 3 * s, py - 1 * s, 2.5 * s, 0, Math.PI * 2);
                    ctx.fill();
                    // Beak
                    ctx.fillStyle = '#d4a020';
                    ctx.beginPath();
                    ctx.moveTo(px + 5 * s, py - 1 * s);
                    ctx.lineTo(px + 8 * s, py);
                    ctx.lineTo(px + 5 * s, py + 1 * s);
                    ctx.closePath();
                    ctx.fill();
                    // Eye
                    ctx.fillStyle = '#202020';
                    ctx.beginPath();
                    ctx.arc(px + 4 * s, py - 1.5 * s, 0.8 * s, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'cat':
                    // Body
                    ctx.fillStyle = '#606060';
                    ctx.beginPath();
                    ctx.ellipse(px, py + 2 * s, 5 * s, 4 * s, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Head
                    ctx.beginPath();
                    ctx.arc(px + 4 * s, py - 2 * s, 4 * s, 0, Math.PI * 2);
                    ctx.fill();
                    // Ears
                    ctx.beginPath();
                    ctx.moveTo(px + 1 * s, py - 4 * s);
                    ctx.lineTo(px + 2 * s, py - 8 * s);
                    ctx.lineTo(px + 4 * s, py - 4 * s);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(px + 5 * s, py - 4 * s);
                    ctx.lineTo(px + 6 * s, py - 8 * s);
                    ctx.lineTo(px + 8 * s, py - 4 * s);
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#90c040';
                    ctx.beginPath();
                    ctx.ellipse(px + 3 * s, py - 2 * s, 1 * s, 1.5 * s, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(px + 6 * s, py - 2 * s, 1 * s, 1.5 * s, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Pupils
                    ctx.fillStyle = '#202020';
                    ctx.fillRect(px + 2.5 * s, py - 3 * s, 1 * s, 2 * s);
                    ctx.fillRect(px + 5.5 * s, py - 3 * s, 1 * s, 2 * s);
                    break;
            }

            ctx.restore();
        }

        function drawWizard(wizard) {
            const px = wizard.x * TILE_SIZE + TILE_SIZE / 2;
            const py = wizard.y * TILE_SIZE + TILE_SIZE / 2;
            const s = TILE_SIZE / 20;
            const element = ELEMENTS[wizard.element];

            // Glow
            ctx.beginPath();
            ctx.arc(px, py, 10 * s, 0, Math.PI * 2);
            const gradient = ctx.createRadialGradient(px, py, 0, px, py, 10 * s);
            gradient.addColorStop(0, element.color + '60');
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.fill();

            // Robe
            ctx.fillStyle = '#3a3a50';
            ctx.beginPath();
            ctx.moveTo(px - 5 * s, py + 8 * s);
            ctx.lineTo(px - 3 * s, py - 2 * s);
            ctx.lineTo(px + 3 * s, py - 2 * s);
            ctx.lineTo(px + 5 * s, py + 8 * s);
            ctx.closePath();
            ctx.fill();

            // Robe trim
            ctx.fillStyle = element.color;
            ctx.fillRect(px - 5 * s, py + 5 * s, 10 * s, 2 * s);

            // Head
            ctx.fillStyle = '#e8c4a0';
            ctx.beginPath();
            ctx.arc(px, py - 4 * s, 4 * s, 0, Math.PI * 2);
            ctx.fill();

            // Hat
            ctx.fillStyle = '#3a3a50';
            ctx.beginPath();
            ctx.moveTo(px - 5 * s, py - 6 * s);
            ctx.lineTo(px, py - 14 * s);
            ctx.lineTo(px + 5 * s, py - 6 * s);
            ctx.closePath();
            ctx.fill();

            // Hat band
            ctx.fillStyle = element.color;
            ctx.fillRect(px - 5 * s, py - 7 * s, 10 * s, 2 * s);

            // Eyes
            ctx.fillStyle = '#202020';
            ctx.fillRect(px - 2 * s, py - 5 * s, 1.5 * s, 1.5 * s);
            ctx.fillRect(px + 1 * s, py - 5 * s, 1.5 * s, 1.5 * s);

            // Staff with element gem
            ctx.fillStyle = '#6b4423';
            ctx.fillRect(px + 6 * s, py - 10 * s, 1.5 * s, 16 * s);
            ctx.fillStyle = element.color;
            ctx.beginPath();
            ctx.arc(px + 6.75 * s, py - 11 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // ============================================
        // UI
        // ============================================
        function updateStatus() {
            document.getElementById('cleared-count').textContent = game.clearedCount;
            document.getElementById('rescued-count').textContent = game.rescuedCount;
            document.getElementById('wizard-count').textContent = game.wizardCount;
        }

        function createBackgroundSnow() {
            const container = document.body;
            for (let i = 0; i < 30; i++) {
                const flake = document.createElement('div');
                flake.className = 'snowflake';
                flake.textContent = ['❄', '❅', '❆', '•'][Math.floor(Math.random() * 4)];
                flake.style.left = Math.random() * 100 + 'vw';
                flake.style.animationDuration = (5 + Math.random() * 10) + 's';
                flake.style.animationDelay = Math.random() * 10 + 's';
                flake.style.fontSize = (0.5 + Math.random() * 1) + 'rem';
                container.appendChild(flake);
            }
        }

        // ============================================
        // GAME LOOP
        // ============================================
        function gameLoop(timestamp) {
            if (!game.running) return;

            update();
            render();

            requestAnimationFrame(gameLoop);
        }

        // ============================================
        // INPUT
        // ============================================
        document.addEventListener('keydown', (e) => {
            // Check if audio init is active
            const audioInitActive = !document.getElementById('audio-init').classList.contains('hidden');
            if (audioInitActive) {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    initGame();
                }
                return;
            }

            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    e.preventDefault();
                    movePlayer(0, -1);
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    e.preventDefault();
                    movePlayer(0, 1);
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    e.preventDefault();
                    movePlayer(-1, 0);
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    e.preventDefault();
                    movePlayer(1, 0);
                    break;
            }
        });

        // Touch/mobile controls
        let touchStartX = 0;
        let touchStartY = 0;

        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });

        canvas.addEventListener('touchend', (e) => {
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;

            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 20) movePlayer(1, 0);
                else if (dx < -20) movePlayer(-1, 0);
            } else {
                if (dy > 20) movePlayer(0, 1);
                else if (dy < -20) movePlayer(0, -1);
            }
        });
    </script>
</body>
</html>
