<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DAILY ROUTINE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&family=Cormorant+Garamond:wght@400;500;600&display=swap');

        :root {
            --void: #0d0d12;
            --room-floor: #1a1816;
            --room-wall: #12100e;
            --text-dim: #5a5550;
            --text-mid: #8a8580;
            --text-bright: #d4cdc0;
            --accent-gold: #d4a574;
            --accent-warm: #c07050;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'IBM Plex Mono', monospace;
            background: linear-gradient(180deg, var(--void) 0%, #1a1612 100%);
            color: var(--text-bright);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            overflow: hidden;
        }

        .container {
            text-align: center;
            max-width: 100%;
        }

        header {
            margin-bottom: 0.75rem;
        }

        h1 {
            font-family: 'Cormorant Garamond', serif;
            font-size: clamp(1.5rem, 3vw, 2rem);
            font-weight: 400;
            letter-spacing: 0.3rem;
            color: var(--accent-gold);
        }

        .subtitle {
            font-size: 0.7rem;
            color: var(--text-dim);
            letter-spacing: 0.15rem;
            font-style: italic;
        }

        #game-container {
            display: inline-block;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(212, 165, 116, 0.2);
            border-radius: 8px;
        }

        canvas {
            display: block;
            border-radius: 4px;
            image-rendering: pixelated;
        }

        /* HUD below canvas */
        .hud {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 0.75rem;
            padding: 0 0.5rem;
            font-size: 0.7rem;
            color: var(--text-dim);
        }

        .hud span {
            color: var(--text-mid);
        }

        /* Wizard */
        .wizard-container {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: flex;
            align-items: flex-end;
            gap: 0.75rem;
            z-index: 100;
        }

        .wizard-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 2px;
            background: rgba(0, 0, 0, 0.5);
            padding: 6px;
            border-radius: 4px;
            width: 70px;
            height: 70px;
        }

        .led {
            aspect-ratio: 1;
            border-radius: 50%;
            background: #1a1a1a;
            transition: all 0.3s ease;
        }

        .led.on {
            background: var(--accent-gold);
            box-shadow: 0 0 3px var(--accent-gold);
        }

        .wizard-speech {
            background: rgba(0, 0, 0, 0.7);
            border-left: 2px solid var(--accent-gold);
            padding: 0.6rem 0.8rem;
            max-width: 250px;
            border-radius: 0 4px 4px 0;
            opacity: 0;
            transform: translateX(-10px);
            transition: all 0.4s ease;
        }

        .wizard-speech.visible {
            opacity: 1;
            transform: translateX(0);
        }

        .wizard-speech p {
            font-size: 0.75rem;
            line-height: 1.5;
            color: var(--text-bright);
            font-style: italic;
        }

        /* Mini-game overlay */
        #minigame-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 15, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        #minigame-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .minigame-container {
            width: 600px;
            max-height: 80vh;
            background: linear-gradient(180deg, #1e1c1a 0%, #141210 100%);
            border: 2px solid var(--accent-gold);
            border-radius: 12px;
            padding: 1.5rem;
        }

        .minigame-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid rgba(212, 165, 116, 0.2);
        }

        .minigame-title {
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.2rem;
            color: var(--accent-gold);
        }

        .minigame-close {
            background: transparent;
            border: 1px solid var(--text-dim);
            color: var(--text-dim);
            padding: 0.3rem 0.6rem;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.65rem;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .minigame-close:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }

        .minigame-content {
            min-height: 250px;
        }

        /* Writing game styles */
        .writing-game { position: relative; }

        .writing-prompt {
            text-align: center;
            margin-bottom: 1rem;
        }

        .writing-prompt .label {
            font-size: 0.65rem;
            color: var(--text-dim);
            margin-bottom: 0.3rem;
        }

        .writing-prompt .prompt-text {
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.1rem;
            color: var(--text-bright);
            font-style: italic;
        }

        .writing-tunnel {
            height: 160px;
            background: linear-gradient(180deg, #0a0a0f 0%, #1a1816 100%);
            border-radius: 6px;
            position: relative;
            overflow: hidden;
            margin-bottom: 0.75rem;
        }

        .thought-orb {
            position: absolute;
            padding: 0.4rem 0.8rem;
            background: rgba(212, 165, 116, 0.2);
            border: 1px solid var(--accent-gold);
            border-radius: 16px;
            font-size: 0.8rem;
            color: var(--text-bright);
            cursor: pointer;
            transition: all 0.3s ease;
            animation: orbFloat 3s ease-in-out infinite;
        }

        .thought-orb:hover {
            background: rgba(212, 165, 116, 0.4);
            transform: scale(1.05);
        }

        .thought-orb.caught {
            background: var(--accent-gold);
            color: var(--void);
            animation: none;
        }

        @keyframes orbFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }

        .writing-output {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(212, 165, 116, 0.2);
            border-radius: 4px;
            padding: 0.75rem;
            min-height: 50px;
            font-family: 'Cormorant Garamond', serif;
            font-size: 0.9rem;
            color: var(--text-mid);
            font-style: italic;
        }

        .writing-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 0.75rem;
            font-size: 0.7rem;
            color: var(--text-dim);
        }

        .flow-meter {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .flow-bar {
            width: 80px;
            height: 5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
            overflow: hidden;
        }

        .flow-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-warm), var(--accent-gold));
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Project selector */
        .project-selector {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .project-option {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(212, 165, 116, 0.2);
            border-radius: 6px;
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .project-option:hover {
            border-color: var(--accent-gold);
            background: rgba(212, 165, 116, 0.1);
        }

        .project-icon { font-size: 1.3rem; }

        .project-info h4 {
            font-family: 'Cormorant Garamond', serif;
            font-size: 1rem;
            color: var(--text-bright);
            margin-bottom: 0.2rem;
        }

        .project-info p {
            font-size: 0.7rem;
            color: var(--text-dim);
        }

        /* Score display */
        .score-display {
            text-align: center;
            padding: 1.5rem;
        }

        .score-display h3 {
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.2rem;
            color: var(--accent-gold);
            margin-bottom: 0.75rem;
        }

        .score-value {
            font-size: 2.5rem;
            color: var(--text-bright);
            margin-bottom: 0.3rem;
        }

        .score-label {
            font-size: 0.75rem;
            color: var(--text-dim);
        }

        .score-btn {
            margin-top: 1rem;
            background: transparent;
            border: 1px solid var(--accent-gold);
            color: var(--accent-gold);
            padding: 0.5rem 1.5rem;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.75rem;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .score-btn:hover {
            background: var(--accent-gold);
            color: var(--void);
        }

        /* Instructions */
        .instructions {
            position: fixed;
            bottom: 20px;
            right: 20px;
            font-size: 0.65rem;
            color: var(--text-dim);
            text-align: right;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Daily Routine</h1>
            <div class="subtitle">a day in the studio</div>
        </header>

        <div id="game-container">
            <canvas id="canvas"></canvas>
        </div>

        <div class="hud">
            <div>projects: <span id="projects-count">0</span></div>
            <div id="interaction-hint"></div>
            <div>energy: <span id="energy-display">100%</span></div>
        </div>
    </div>

    <!-- Wizard -->
    <div class="wizard-container">
        <div class="wizard-grid" id="wizard-grid"></div>
        <div class="wizard-speech" id="wizard-speech">
            <p id="wizard-text"></p>
        </div>
    </div>

    <!-- Instructions -->
    <div class="instructions">
        wasd or arrows to move<br>
        e or space to interact
    </div>

    <!-- Mini-game Overlay -->
    <div id="minigame-overlay">
        <div class="minigame-container">
            <div class="minigame-header">
                <div class="minigame-title" id="minigame-title">Select Project</div>
                <button class="minigame-close" onclick="closeMinigame()">‚Üê back</button>
            </div>
            <div class="minigame-content" id="minigame-content"></div>
        </div>
    </div>

    <audio id="music" loop>
        <source src="music/daily-routine.mp3" type="audio/mpeg">
    </audio>

    <script>
        // ============================================
        // CONSTANTS
        // ============================================
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const TILE_SIZE = 24;
        const GRID_WIDTH = 20;
        const GRID_HEIGHT = 14;

        const TILE = {
            FLOOR: 0,
            WALL: 1,
            RUG: 2,
            STATION_MUSIC: 3,
            STATION_DIGITAL: 4,
            STATION_CRAFT: 5
        };

        const COLORS = {
            floor: '#1e1a17',
            floorAlt: '#1a1614',
            wall: '#12100e',
            wallTop: '#2a2520',
            rug: '#2d2822',
            rugPattern: '#352f28',
            stationBase: '#252220',
            stationGlow: 'rgba(212, 165, 116, 0.15)',
            stationActive: 'rgba(212, 165, 116, 0.4)'
        };

        // ============================================
        // GAME STATE
        // ============================================
        const game = {
            grid: [],
            player: { x: 10, y: 10 },
            facing: 'down',
            projectsCompleted: 0,
            energy: 100,
            nearStation: null,
            running: false,
            lastMoveTime: 0,
            ttsEnabled: true
        };

        const STATIONS = {
            music: { x: 3, y: 3, w: 3, h: 2, name: 'The Keyboard', icon: 'üéπ' },
            digital: { x: 9, y: 2, w: 3, h: 2, name: 'The Workstation', icon: 'üñ•Ô∏è' },
            craft: { x: 15, y: 3, w: 3, h: 2, name: 'The Workshop', icon: 'ü™µ' }
        };

        // ============================================
        // WIZARD
        // ============================================
        const WIZARD_FACES = {
            calm: {
                pattern: [
                    0,0,0,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,0,0,0,
                    0,0,1,1,0,0,1,1,0,0,
                    0,0,1,1,0,0,1,1,0,0,
                    0,0,0,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,0,0,0,
                    0,0,1,1,1,1,1,1,0,0,
                    0,0,0,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,0,0,0
                ]
            },
            curious: {
                pattern: [
                    0,0,0,0,0,0,0,0,0,0,
                    0,0,1,1,0,0,1,1,0,0,
                    0,0,1,1,0,0,1,1,0,0,
                    0,0,1,1,0,0,1,1,0,0,
                    0,0,0,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,0,0,0,
                    0,0,0,1,1,1,1,0,0,0,
                    0,0,1,0,0,0,0,1,0,0,
                    0,0,0,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,0,0,0
                ]
            },
            pleased: {
                pattern: [
                    0,0,0,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,0,0,0,
                    0,0,1,1,0,0,1,1,0,0,
                    0,0,1,1,0,0,1,1,0,0,
                    0,0,0,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,0,0,0,
                    0,1,0,0,0,0,0,0,1,0,
                    0,0,1,0,0,0,0,1,0,0,
                    0,0,0,1,1,1,1,0,0,0,
                    0,0,0,0,0,0,0,0,0,0
                ]
            },
            thinking: {
                pattern: [
                    0,0,0,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,0,0,0,
                    0,0,1,1,0,0,1,1,0,0,
                    0,0,1,1,0,0,1,1,0,0,
                    0,0,0,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,0,0,0,
                    0,0,0,0,1,1,0,0,0,0,
                    0,0,0,0,0,0,1,1,0,0,
                    0,0,0,0,0,0,0,0,0,0
                ]
            }
        };

        const WIZARD_DIALOGUE = {
            greeting: [
                "Another day in the studio. What shall we create?",
                "The workspace awaits. Where will you begin?",
                "Creativity stirs. Take your time."
            ],
            music: [
                "Music speaks where words cannot.",
                "Let rhythm guide your hands.",
                "Every note tells a story."
            ],
            digital: [
                "Words flow like water when we let them.",
                "The screen holds infinite possibility.",
                "Build something meaningful."
            ],
            craft: [
                "Feel the material beneath your fingers.",
                "Patience reveals the form within.",
                "Create with care."
            ],
            complete: [
                "Well done. The work is its own reward.",
                "Another piece finds its shape.",
                "Creation complete. What's next?"
            ]
        };

        let leds = [];

        function initWizard() {
            const grid = document.getElementById('wizard-grid');
            for (let i = 0; i < 100; i++) {
                const led = document.createElement('div');
                led.className = 'led';
                grid.appendChild(led);
                leds.push(led);
            }
            setWizardMood('calm');
        }

        function setWizardMood(mood) {
            const face = WIZARD_FACES[mood];
            if (!face) return;
            face.pattern.forEach((state, index) => {
                if (state === 1) {
                    leds[index].classList.add('on');
                } else {
                    leds[index].classList.remove('on');
                }
            });
        }

        function wizardSpeak(text, mood = 'calm') {
            const speech = document.getElementById('wizard-speech');
            const textEl = document.getElementById('wizard-text');

            textEl.textContent = text;
            speech.classList.add('visible');
            setWizardMood(mood);

            if (game.ttsEnabled && 'speechSynthesis' in window) {
                window.speechSynthesis.cancel();
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 0.85;
                utterance.pitch = 0.9;
                utterance.volume = 0.7;
                window.speechSynthesis.speak(utterance);
            }

            setTimeout(() => {
                speech.classList.remove('visible');
            }, 5000);
        }

        // ============================================
        // MAP
        // ============================================
        function generateMap() {
            game.grid = [];

            for (let y = 0; y < GRID_HEIGHT; y++) {
                game.grid[y] = [];
                for (let x = 0; x < GRID_WIDTH; x++) {
                    // Walls on top
                    if (y < 2) {
                        game.grid[y][x] = TILE.WALL;
                    }
                    // Floor
                    else {
                        game.grid[y][x] = TILE.FLOOR;
                    }
                }
            }

            // Add rug in center
            for (let y = 7; y < 12; y++) {
                for (let x = 6; x < 14; x++) {
                    game.grid[y][x] = TILE.RUG;
                }
            }
        }

        // ============================================
        // RENDERING
        // ============================================
        function draw() {
            ctx.fillStyle = COLORS.wall;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw tiles
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const tile = game.grid[y][x];
                    const px = x * TILE_SIZE;
                    const py = y * TILE_SIZE;

                    switch (tile) {
                        case TILE.WALL:
                            ctx.fillStyle = y === 1 ? COLORS.wallTop : COLORS.wall;
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            break;
                        case TILE.FLOOR:
                            ctx.fillStyle = (x + y) % 2 === 0 ? COLORS.floor : COLORS.floorAlt;
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            break;
                        case TILE.RUG:
                            ctx.fillStyle = (x + y) % 2 === 0 ? COLORS.rug : COLORS.rugPattern;
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            break;
                    }
                }
            }

            // Draw stations
            drawStation(STATIONS.music, 'music');
            drawStation(STATIONS.digital, 'digital');
            drawStation(STATIONS.craft, 'craft');

            // Draw player
            drawPlayer();

            // Update interaction hint
            updateInteractionHint();
        }

        function drawStation(station, type) {
            const px = station.x * TILE_SIZE;
            const py = station.y * TILE_SIZE;
            const pw = station.w * TILE_SIZE;
            const ph = station.h * TILE_SIZE;

            const isNear = game.nearStation === type;

            // Glow effect when near
            if (isNear) {
                ctx.fillStyle = COLORS.stationActive;
                ctx.fillRect(px - 4, py - 4, pw + 8, ph + 8);
            }

            // Station base (desk/table)
            ctx.fillStyle = COLORS.stationBase;
            ctx.fillRect(px, py, pw, ph);

            // Station top highlight
            ctx.fillStyle = isNear ? '#3a3530' : '#2a2520';
            ctx.fillRect(px + 2, py + 2, pw - 4, ph - 8);

            // Draw station-specific items
            const cx = px + pw / 2;
            const cy = py + ph / 2;

            ctx.font = '20px serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(station.icon, cx, cy - 4);

            // Station name when near
            if (isNear) {
                ctx.font = '9px "IBM Plex Mono"';
                ctx.fillStyle = '#d4a574';
                ctx.fillText(station.name, cx, py + ph + 12);
            }
        }

        function drawPlayer() {
            const px = game.player.x * TILE_SIZE + TILE_SIZE / 2;
            const py = game.player.y * TILE_SIZE + TILE_SIZE / 2;
            const s = TILE_SIZE / 20;

            // Gentle bob animation
            const bob = Math.sin(Date.now() / 400) * 0.5;

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.ellipse(px, py + 7 * s, 5 * s, 2.5 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Body (cozy sweater)
            ctx.fillStyle = '#6b5a4a';
            ctx.fillRect(px - 4 * s, py - 3 * s + bob, 8 * s, 10 * s);

            // Head
            ctx.fillStyle = '#e8c4a0';
            ctx.beginPath();
            ctx.arc(px, py - 5 * s + bob, 4 * s, 0, Math.PI * 2);
            ctx.fill();

            // Hair
            ctx.fillStyle = '#4a3a2a';
            ctx.beginPath();
            ctx.arc(px, py - 7 * s + bob, 4 * s, Math.PI, Math.PI * 2);
            ctx.fill();
            ctx.fillRect(px - 4 * s, py - 7 * s + bob, 8 * s, 2 * s);

            // Eyes
            ctx.fillStyle = '#202020';
            ctx.fillRect(px - 2 * s, py - 5 * s + bob, 1.5 * s, 1.5 * s);
            ctx.fillRect(px + 0.5 * s, py - 5 * s + bob, 1.5 * s, 1.5 * s);

            // Arms
            ctx.fillStyle = '#6b5a4a';
            ctx.fillRect(px - 6 * s, py - 1 * s + bob, 2 * s, 6 * s);
            ctx.fillRect(px + 4 * s, py - 1 * s + bob, 2 * s, 6 * s);

            // Hands
            ctx.fillStyle = '#e8c4a0';
            ctx.fillRect(px - 6 * s, py + 4 * s + bob, 2 * s, 2 * s);
            ctx.fillRect(px + 4 * s, py + 4 * s + bob, 2 * s, 2 * s);
        }

        // ============================================
        // MOVEMENT
        // ============================================
        function canMove() {
            const now = Date.now();
            return (now - game.lastMoveTime) >= 120;
        }

        function movePlayer(dx, dy) {
            if (!canMove()) return;

            const newX = game.player.x + dx;
            const newY = game.player.y + dy;

            // Update facing
            if (dx > 0) game.facing = 'right';
            else if (dx < 0) game.facing = 'left';
            else if (dy > 0) game.facing = 'down';
            else if (dy < 0) game.facing = 'up';

            // Check bounds
            if (newX < 0 || newX >= GRID_WIDTH || newY < 2 || newY >= GRID_HEIGHT) return;

            // Check station collision
            for (const [type, station] of Object.entries(STATIONS)) {
                if (newX >= station.x && newX < station.x + station.w &&
                    newY >= station.y && newY < station.y + station.h) {
                    return;
                }
            }

            game.player.x = newX;
            game.player.y = newY;
            game.lastMoveTime = Date.now();

            playSound('step');
            checkNearStation();
        }

        function checkNearStation() {
            game.nearStation = null;

            for (const [type, station] of Object.entries(STATIONS)) {
                // Check if player is adjacent to station
                const playerInRange =
                    game.player.x >= station.x - 1 && game.player.x <= station.x + station.w &&
                    game.player.y >= station.y - 1 && game.player.y <= station.y + station.h;

                if (playerInRange) {
                    game.nearStation = type;

                    // Wizard comments on station
                    if (Math.random() < 0.1) {
                        const dialogueKey = type === 'music' ? 'music' : type === 'digital' ? 'digital' : 'craft';
                        wizardSpeak(randomFrom(WIZARD_DIALOGUE[dialogueKey]), 'curious');
                    }
                    break;
                }
            }
        }

        function updateInteractionHint() {
            const hint = document.getElementById('interaction-hint');
            if (game.nearStation) {
                hint.textContent = '[E] to work';
                hint.style.color = '#d4a574';
            } else {
                hint.textContent = '';
            }
        }

        function interact() {
            if (game.nearStation) {
                openStation(game.nearStation);
            }
        }

        // ============================================
        // AUDIO
        // ============================================
        let audioContext = null;

        function initAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playSound(type) {
            if (!audioContext) return;

            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain);
            gain.connect(audioContext.destination);

            switch(type) {
                case 'step':
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(80 + Math.random() * 30, now);
                    gain.gain.setValueAtTime(0.03, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.06);
                    osc.start(now);
                    osc.stop(now + 0.06);
                    break;

                case 'interact':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.setValueAtTime(500, now + 0.05);
                    gain.gain.setValueAtTime(0.08, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                    break;

                case 'complete':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.setValueAtTime(500, now + 0.1);
                    osc.frequency.setValueAtTime(600, now + 0.2);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    osc.start(now);
                    osc.stop(now + 0.3);
                    break;
            }
        }

        // ============================================
        // STATIONS & MINI-GAMES
        // ============================================
        const STATION_PROJECTS = {
            music: [
                { id: 'music', name: 'The Pulse Weaver', desc: 'Compose with rhythm', icon: 'üéµ' }
            ],
            digital: [
                { id: 'writing', name: 'Stream of Consciousness', desc: 'Catch thoughts, form sentences', icon: '‚úçÔ∏è' },
                { id: 'coding', name: 'Logic Leak', desc: 'Route data, fix bugs', icon: 'üíª' }
            ],
            craft: [
                { id: 'painting', name: 'Chroma Alchemist', desc: 'Mix colors, paint targets', icon: 'üé®' },
                { id: 'woodworking', name: 'Grain & Gauge', desc: 'Shape with precision', icon: 'ü™ö' }
            ]
        };

        function openStation(stationType) {
            playSound('interact');
            showProjectSelector(stationType);

            const dialogueKey = stationType === 'music' ? 'music' : stationType === 'digital' ? 'digital' : 'craft';
            wizardSpeak(randomFrom(WIZARD_DIALOGUE[dialogueKey]), 'curious');
        }

        function showProjectSelector(stationType) {
            const projects = STATION_PROJECTS[stationType];
            const content = document.getElementById('minigame-content');

            document.getElementById('minigame-title').textContent = 'Select Project';

            let html = '<div class="project-selector">';
            projects.forEach(project => {
                html += `
                    <div class="project-option" onclick="startProject('${project.id}')">
                        <div class="project-icon">${project.icon}</div>
                        <div class="project-info">
                            <h4>${project.name}</h4>
                            <p>${project.desc}</p>
                        </div>
                    </div>
                `;
            });
            html += '</div>';

            content.innerHTML = html;
            document.getElementById('minigame-overlay').classList.add('active');
        }

        function startProject(projectId) {
            switch (projectId) {
                case 'writing':
                    startWritingGame();
                    break;
                default:
                    showComingSoon(projectId);
                    break;
            }
        }

        function closeMinigame() {
            document.getElementById('minigame-overlay').classList.remove('active');
        }

        // ============================================
        // WRITING MINI-GAME
        // ============================================
        const WRITING_PROMPTS = [
            { theme: 'memory', words: ['once', 'there was', 'a place', 'where light', 'never faded'] },
            { theme: 'journey', words: ['they walked', 'through mist', 'and found', 'a door', 'that led home'] },
            { theme: 'creation', words: ['from nothing', 'came a spark', 'that grew', 'into something', 'beautiful'] }
        ];

        let writingState = { prompt: null, caughtWords: [], flow: 0 };

        function startWritingGame() {
            document.getElementById('minigame-title').textContent = 'Stream of Consciousness';

            writingState = {
                prompt: randomFrom(WRITING_PROMPTS),
                caughtWords: [],
                flow: 0
            };

            const content = document.getElementById('minigame-content');
            content.innerHTML = `
                <div class="writing-game">
                    <div class="writing-prompt">
                        <div class="label">theme</div>
                        <div class="prompt-text">${writingState.prompt.theme}</div>
                    </div>
                    <div class="writing-tunnel" id="writing-tunnel"></div>
                    <div class="writing-output" id="writing-output">
                        <span style="opacity:0.5">catch the words in order...</span>
                    </div>
                    <div class="writing-stats">
                        <div class="flow-meter">
                            flow: <div class="flow-bar"><div class="flow-fill" id="flow-fill"></div></div>
                        </div>
                        <div>words: <span id="word-count">0</span>/${writingState.prompt.words.length}</div>
                    </div>
                </div>
            `;

            spawnThoughtOrbs();
        }

        function spawnThoughtOrbs() {
            const tunnel = document.getElementById('writing-tunnel');
            const words = writingState.prompt.words;

            words.forEach((word, index) => {
                const orb = document.createElement('div');
                orb.className = 'thought-orb';
                orb.textContent = word;
                orb.style.left = (15 + Math.random() * 60) + '%';
                orb.style.top = (15 + Math.random() * 55) + '%';
                orb.style.animationDelay = (index * 0.2) + 's';
                orb.dataset.index = index;
                orb.onclick = () => catchWord(orb, index);
                tunnel.appendChild(orb);
            });
        }

        function catchWord(orb, index) {
            if (orb.classList.contains('caught')) return;

            const expectedIndex = writingState.caughtWords.length;
            const words = writingState.prompt.words;

            if (index === expectedIndex) {
                orb.classList.add('caught');
                writingState.caughtWords.push(words[index]);
                writingState.flow = Math.min(100, writingState.flow + 20);

                const output = document.getElementById('writing-output');
                output.innerHTML = '"' + writingState.caughtWords.join(' ') +
                    (writingState.caughtWords.length < words.length ? '...' : '.') + '"';

                document.getElementById('flow-fill').style.width = writingState.flow + '%';
                document.getElementById('word-count').textContent = writingState.caughtWords.length;

                if (writingState.caughtWords.length === words.length) {
                    completeWritingGame();
                }
            } else {
                writingState.flow = Math.max(0, writingState.flow - 10);
                document.getElementById('flow-fill').style.width = writingState.flow + '%';
            }
        }

        function completeWritingGame() {
            const score = Math.round(writingState.flow * 1.5);
            game.projectsCompleted++;
            updateHUD();

            setTimeout(() => {
                showScore(score);
                playSound('complete');
                wizardSpeak(randomFrom(WIZARD_DIALOGUE.complete), 'pleased');
            }, 500);
        }

        function showComingSoon(projectId) {
            document.getElementById('minigame-title').textContent = projectId.charAt(0).toUpperCase() + projectId.slice(1);
            document.getElementById('minigame-content').innerHTML = `
                <div class="score-display">
                    <h3>Coming Soon</h3>
                    <p class="score-label">This project is still being prepared.</p>
                    <button class="score-btn" onclick="closeMinigame()">return</button>
                </div>
            `;
        }

        function showScore(score) {
            document.getElementById('minigame-content').innerHTML = `
                <div class="score-display">
                    <h3>Project Complete</h3>
                    <div class="score-value">${score}</div>
                    <div class="score-label">creative points</div>
                    <button class="score-btn" onclick="closeMinigame()">continue</button>
                </div>
            `;
        }

        function updateHUD() {
            document.getElementById('projects-count').textContent = game.projectsCompleted;
            document.getElementById('energy-display').textContent = game.energy + '%';
        }

        // ============================================
        // GAME LOOP
        // ============================================
        function gameLoop() {
            draw();
            requestAnimationFrame(gameLoop);
        }

        // ============================================
        // INPUT
        // ============================================
        document.addEventListener('keydown', (e) => {
            if (document.getElementById('minigame-overlay').classList.contains('active')) return;

            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    e.preventDefault();
                    movePlayer(0, -1);
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    e.preventDefault();
                    movePlayer(0, 1);
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    e.preventDefault();
                    movePlayer(-1, 0);
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    e.preventDefault();
                    movePlayer(1, 0);
                    break;
                case 'e':
                case 'E':
                case ' ':
                    e.preventDefault();
                    interact();
                    break;
            }
        });

        // ============================================
        // UTILITIES
        // ============================================
        function randomFrom(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        // ============================================
        // INIT
        // ============================================
        function init() {
            canvas.width = GRID_WIDTH * TILE_SIZE;
            canvas.height = GRID_HEIGHT * TILE_SIZE;

            initWizard();
            initAudio();
            generateMap();

            // Start music on first interaction
            const music = document.getElementById('music');
            music.volume = 0.3;
            document.addEventListener('click', () => {
                if (music.paused) music.play().catch(() => {});
            }, { once: true });
            document.addEventListener('keydown', () => {
                if (music.paused) music.play().catch(() => {});
            }, { once: true });

            // Initial greeting
            setTimeout(() => {
                wizardSpeak(randomFrom(WIZARD_DIALOGUE.greeting), 'calm');
            }, 800);

            gameLoop();
        }

        init();
    </script>
</body>
</html>
