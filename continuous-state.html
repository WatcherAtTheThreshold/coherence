<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CONTINUOUS STATE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&family=Cormorant+Garamond:wght@400;600&display=swap');

        :root {
            --earth-deep: #1a1612;
            --earth-warm: #2d2620;
            --stone-dark: #3d3832;
            --stone-mid: #5c554d;
            --stone-light: #8a8279;
            --sand: #c4b8a5;
            --clay: #9c7c5c;
            --moss: #5c6b4a;
            --moss-light: #7a8c66;
            --water: #5c7a8c;
            --stress-warm: #8c5c4a;
            --stress-hot: #a64c3c;
            --settled: #6b6458;
            --text-dim: #6b635a;
            --text-bright: #d4cdc0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'IBM Plex Mono', monospace;
            background: var(--earth-deep);
            color: var(--text-bright);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
            padding: 1rem;
        }

        /* Subtle grain texture - only visible in stressed state */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.4' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.02'/%3E%3C/svg%3E");
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 2s ease;
        }

        body.stressed::before {
            opacity: 1;
        }

        .container {
            position: relative;
            z-index: 2;
            text-align: center;
            max-width: 100%;
        }

        header {
            margin-bottom: 1.5rem;
            animation: fadeIn 1.5s ease-out;
        }

        h1 {
            font-family: 'Cormorant Garamond', serif;
            font-size: clamp(1.8rem, 4vw, 2.5rem);
            font-weight: 400;
            letter-spacing: 0.4rem;
            text-transform: uppercase;
            color: var(--sand);
            filter: drop-shadow(0 2px 8px rgba(196, 184, 165, 0.2));
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-size: clamp(0.65rem, 1.5vw, 0.8rem);
            color: var(--text-dim);
            letter-spacing: 0.25rem;
            text-transform: lowercase;
            font-style: italic;
        }

        #game-container {
            background: var(--earth-warm);
            border: 1px solid var(--stone-dark);
            padding: 1.5rem;
            border-radius: 2px;
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.5),
                0 2px 8px rgba(0, 0, 0, 0.3),
                inset 0 1px 2px rgba(255, 255, 255, 0.03),
                inset 0 0 40px rgba(0, 0, 0, 0.3);
            animation: fadeIn 1.5s ease-out 0.3s both;
            display: inline-block;
        }

        #grid-container {
            position: relative;
            width: min(85vw, 500px);
            height: min(85vw, 500px);
            max-width: 500px;
            max-height: 500px;
            background: linear-gradient(180deg, var(--earth-deep) 0%, rgba(26, 22, 18, 0.95) 100%);
            border: 1px solid var(--stone-dark);
            border-radius: 2px;
            box-shadow:
                inset 0 0 30px rgba(0, 0, 0, 0.6),
                inset 0 4px 12px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }

        .tile {
            position: absolute;
            border-radius: 4px;
            cursor: grab;
            transition: box-shadow 0.3s ease, transform 0.1s ease;
            user-select: none;
            -webkit-user-select: none;
            overflow: hidden;
        }

        .tile:active {
            cursor: grabbing;
        }

        /* Highlight strip on top */
        .tile::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 25%;
            border-radius: 4px 4px 50% 50%;
            background: linear-gradient(180deg, rgba(255,255,255,0.25) 0%, rgba(255,255,255,0) 100%);
            pointer-events: none;
        }

        /* Shadow strip on bottom */
        .tile::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 20%;
            border-radius: 0 0 4px 4px;
            background: linear-gradient(180deg, transparent 0%, rgba(0,0,0,0.25) 100%);
            pointer-events: none;
        }

        .tile.stone {
            background: linear-gradient(160deg, #6a6258 0%, var(--stone-mid) 40%, var(--stone-dark) 100%);
            box-shadow:
                0 3px 8px rgba(0, 0, 0, 0.45),
                0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .tile.soil {
            background: linear-gradient(160deg, #b89070 0%, var(--clay) 40%, #7a5a40 100%);
            box-shadow:
                0 3px 8px rgba(0, 0, 0, 0.4),
                0 1px 3px rgba(0, 0, 0, 0.25);
        }

        .tile.moss {
            background: linear-gradient(160deg, #90c080 0%, var(--moss-light) 40%, var(--moss) 100%);
            box-shadow:
                0 3px 8px rgba(0, 0, 0, 0.4),
                0 1px 3px rgba(0, 0, 0, 0.25);
        }

        .tile.water {
            background: linear-gradient(160deg, #7a9aac 0%, var(--water) 40%, #4a6a7c 100%);
            box-shadow:
                0 3px 8px rgba(0, 0, 0, 0.35),
                0 1px 3px rgba(0, 0, 0, 0.2);
        }

        /* Subtle texture marks - different for each type */
        .tile.stone .texture-mark,
        .tile.soil .texture-mark,
        .tile.moss .texture-mark,
        .tile.water .texture-mark {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            opacity: 0.3;
        }

        /* Stress states */
        .tile.strained {
            animation: strain 0.5s ease-in-out infinite;
        }

        .tile.stressed {
            animation: stress 0.3s ease-in-out infinite;
            box-shadow:
                0 3px 8px rgba(0, 0, 0, 0.4),
                0 0 10px rgba(166, 76, 60, 0.35),
                0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .tile.cracked .crack-line {
            position: absolute;
            top: 20%;
            left: 30%;
            width: 40%;
            height: 60%;
            background: linear-gradient(45deg, transparent 40%, rgba(0,0,0,0.4) 45%, transparent 50%);
            pointer-events: none;
            z-index: 2;
        }

        .tile.settled {
            filter: saturate(0.85) brightness(0.92);
            transition: filter 2s ease;
        }

        /* Settled indicator dots */
        .tile.settled .settled-dot {
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.4);
            pointer-events: none;
            z-index: 1;
        }

        .tile.falling {
            transition: top 0.15s ease-in, left 0.15s ease-out;
        }

        .tile.sliding {
            transition: left 0.2s ease-out, top 0.2s ease-out;
        }

        .tile.dragging {
            z-index: 100;
            box-shadow:
                0 12px 28px rgba(0, 0, 0, 0.5),
                0 6px 12px rgba(0, 0, 0, 0.35);
            transform: scale(1.05);
            cursor: grabbing;
            filter: brightness(1.1);
        }

        @keyframes strain {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-0.5px); }
            75% { transform: translateX(0.5px); }
        }

        @keyframes stress {
            0%, 100% { transform: translate(0, 0); }
            20% { transform: translate(-1px, 0.5px); }
            40% { transform: translate(1px, -0.5px); }
            60% { transform: translate(-0.5px, 1px); }
            80% { transform: translate(0.5px, -1px); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Coherence indicator - subtle, ambient */
        #coherence-field {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 2s ease;
            background: radial-gradient(circle at center, transparent 40%, rgba(166, 76, 60, 0.1) 100%);
        }

        #coherence-field.low {
            opacity: 1;
        }

        /* Status indicator - above grid */
        #status {
            margin-bottom: 1rem;
            font-size: clamp(0.75rem, 1.5vw, 0.9rem);
            letter-spacing: 0.2rem;
            padding: 0.5rem 1.5rem;
            background: transparent;
            border: none;
            display: block;
            color: var(--text-dim);
            text-align: center;
        }

        #status .state-text {
            transition: color 1s ease;
        }

        #status .state-text.coherent {
            color: var(--moss-light);
        }

        #status .state-text.unsettled {
            color: var(--clay);
        }

        #status .state-text.chaotic {
            color: var(--stress-warm);
        }

        .instructions {
            margin-top: 1rem;
            margin-bottom: 0.75rem;
            font-size: clamp(0.6rem, 1.3vw, 0.75rem);
            color: var(--text-dim);
            letter-spacing: 0.1rem;
            animation: fadeIn 1.5s ease-out 0.6s both;
            font-style: italic;
            text-align: center;
        }

        /* Rest button - below everything, centered */
        #rest-btn {
            display: block;
            margin: 0 auto;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.75rem;
            padding: 0.5rem 1.5rem;
            background: transparent;
            border: 1px solid var(--stone-dark);
            color: var(--text-dim);
            cursor: pointer;
            transition: all 0.5s ease;
            text-transform: lowercase;
            letter-spacing: 0.15rem;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        #rest-btn:hover {
            border-color: var(--sand);
            color: var(--sand);
            box-shadow: 0 2px 12px rgba(196, 184, 165, 0.15);
        }

        /* Audio init overlay */
        #audio-init {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--earth-deep);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            transition: opacity 1s ease;
        }

        #audio-init.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .init-content {
            text-align: center;
            padding: 2rem;
        }

        .init-content h2 {
            font-family: 'Cormorant Garamond', serif;
            font-size: clamp(1.5rem, 4vw, 2rem);
            font-weight: 400;
            letter-spacing: 0.3rem;
            color: var(--sand);
            margin-bottom: 1rem;
        }

        .init-content p {
            font-size: 0.85rem;
            color: var(--text-dim);
            margin-bottom: 1.5rem;
            font-style: italic;
        }

        .init-content button {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9rem;
            padding: 0.75rem 2rem;
            background: transparent;
            border: 1px solid var(--sand);
            color: var(--sand);
            cursor: pointer;
            transition: all 0.5s ease;
            text-transform: lowercase;
            letter-spacing: 0.2rem;
            box-shadow:
                0 2px 8px rgba(0, 0, 0, 0.3),
                inset 0 1px 2px rgba(196, 184, 165, 0.1);
        }

        .init-content button:hover,
        .init-content button:focus {
            background: var(--sand);
            color: var(--earth-deep);
            box-shadow:
                0 4px 16px rgba(196, 184, 165, 0.3),
                inset 0 1px 2px rgba(255, 255, 255, 0.2);
            outline: none;
        }

        /* Fade out overlay for rest */
        #fade-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--earth-deep);
            opacity: 0;
            pointer-events: none;
            z-index: 2500;
            transition: opacity 3s ease;
        }

        #fade-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        #wake-btn {
            position: absolute;
            bottom: 3rem;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.85rem;
            padding: 0.6rem 2rem;
            background: transparent;
            border: 1px solid var(--stone-dark);
            color: var(--text-dim);
            cursor: pointer;
            transition: all 0.5s ease;
            text-transform: lowercase;
            letter-spacing: 0.2rem;
            opacity: 0;
            pointer-events: none;
        }

        #fade-overlay.active #wake-btn {
            opacity: 1;
            pointer-events: all;
            animation: fadeIn 2s ease-out 1s both;
        }

        #wake-btn:hover,
        #wake-btn:focus {
            border-color: var(--sand);
            color: var(--sand);
            box-shadow: 0 2px 12px rgba(196, 184, 165, 0.15);
            outline: none;
        }
    </style>
</head>
<body>
    <!-- Audio init overlay -->
    <div id="audio-init">
        <div class="init-content">
            <h2>Continuous State</h2>
            <p>a system to tend</p>
            <button id="init-audio-btn" onclick="initAudio()" autofocus>begin</button>
        </div>
    </div>

    <!-- Fade overlay for rest -->
    <div id="fade-overlay">
        <button id="wake-btn" onclick="wake()">wake</button>
    </div>

    <div class="container">
        <header>
            <h1>Continuous State</h1>
            <div class="subtitle">observe, intervene, wait</div>
        </header>

        <div id="status">
            <span class="state-text coherent">stillness</span>
        </div>

        <div id="game-container">
            <div id="grid-container">
                <div id="coherence-field"></div>
                <!-- Tiles will be generated here -->
            </div>
        </div>

        <div class="instructions">
            drag tiles gently to intervene
        </div>

        <button id="rest-btn" onclick="rest()">rest</button>
    </div>

    <!-- Audio elements -->
    <audio id="music-coherent" loop>
        <source src="music/ambient.mp3" type="audio/mpeg">
    </audio>
    <audio id="music-chaotic" loop>
        <source src="music/ambient2.mp3" type="audio/mpeg">
    </audio>

    <script>
        // Audio system
        const audioCoherent = document.getElementById('music-coherent');
        const audioChaotic = document.getElementById('music-chaotic');
        let audioContext = null;
        let audioInitialized = false;

        // Target volumes for crossfade
        let coherentVolume = 0.5;
        let chaoticVolume = 0;

        function initAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();

            audioCoherent.volume = 0.5;
            audioChaotic.volume = 0;

            // Start both tracks
            audioCoherent.play().catch(err => console.log('Audio error:', err));
            audioChaotic.play().catch(err => console.log('Audio error:', err));

            audioInitialized = true;

            // Fade out init screen
            document.getElementById('audio-init').classList.add('hidden');

            // Start the simulation
            setTimeout(initGame, 500);
        }

        // Crossfade music based on coherence
        function updateMusic(coherence) {
            if (!audioInitialized) return;

            // Map coherence (0-100) to volumes
            // High coherence = more ambient, less chaotic
            const normalizedCoherence = coherence / 100;

            coherentVolume = 0.1 + (normalizedCoherence * 0.4);
            chaoticVolume = 0.4 - (normalizedCoherence * 0.35);

            // Smooth crossfade
            const fadeStep = () => {
                const diff1 = coherentVolume - audioCoherent.volume;
                const diff2 = chaoticVolume - audioChaotic.volume;

                if (Math.abs(diff1) > 0.01) {
                    audioCoherent.volume += diff1 * 0.05;
                }
                if (Math.abs(diff2) > 0.01) {
                    audioChaotic.volume += diff2 * 0.05;
                }
            };

            fadeStep();
        }

        // Sound throttling to prevent crackling
        const soundCooldowns = {
            place: 0,
            slide: 0,
            crack: 0,
            settle: 0
        };
        const soundMinIntervals = {
            place: 100,   // ms between place sounds
            slide: 200,   // ms between slide sounds
            crack: 300,   // ms between crack sounds
            settle: 500   // ms between settle sounds
        };

        // Procedural sounds - disabled for now (was causing crackling)
        function playSound(type) {
            // Sounds disabled - relying on ambient music only
            return;
        }

        // Game state
        const state = {
            tiles: [],
            coherence: 75,
            dragging: null,
            dragOffset: { x: 0, y: 0 },
            gridWidth: 500,
            gridHeight: 500,
            tileSize: 40,
            gravity: 0.5,
            running: true,
            lastUpdate: 0
        };

        // Tile types with weights
        const tileTypes = {
            stone: { weight: 3, color: 'stone' },
            soil: { weight: 2, color: 'soil' },
            moss: { weight: 1, color: 'moss' },
            water: { weight: 1, color: 'water' }
        };

        // Initialize game
        function initGame() {
            const container = document.getElementById('grid-container');
            const rect = container.getBoundingClientRect();
            state.gridWidth = rect.width;
            state.gridHeight = rect.height;

            // Create initial tile arrangement
            createInitialTiles();

            // Start game loop
            requestAnimationFrame(gameLoop);

            // Set up event listeners
            setupDragListeners();
        }

        function createInitialTiles() {
            const container = document.getElementById('grid-container');
            state.tiles = [];

            // Create a rich starting arrangement with ~40 tiles
            const arrangements = [
                // Bottom foundation layer - wide and stable
                { x: 50, y: 455, type: 'stone', width: 70, height: 35 },
                { x: 125, y: 455, type: 'stone', width: 65, height: 35 },
                { x: 195, y: 455, type: 'stone', width: 60, height: 35 },
                { x: 260, y: 455, type: 'stone', width: 65, height: 35 },
                { x: 330, y: 455, type: 'stone', width: 70, height: 35 },
                { x: 405, y: 455, type: 'stone', width: 60, height: 35 },

                // Second layer
                { x: 70, y: 415, type: 'stone', width: 55, height: 35 },
                { x: 130, y: 415, type: 'soil', width: 50, height: 35 },
                { x: 185, y: 415, type: 'stone', width: 55, height: 35 },
                { x: 245, y: 415, type: 'soil', width: 50, height: 35 },
                { x: 300, y: 415, type: 'stone', width: 55, height: 35 },
                { x: 360, y: 415, type: 'soil', width: 50, height: 35 },
                { x: 415, y: 415, type: 'stone', width: 45, height: 35 },

                // Third layer
                { x: 90, y: 375, type: 'soil', width: 45, height: 35 },
                { x: 145, y: 375, type: 'stone', width: 50, height: 35 },
                { x: 200, y: 375, type: 'soil', width: 45, height: 35 },
                { x: 250, y: 375, type: 'moss', width: 40, height: 30 },
                { x: 295, y: 375, type: 'soil', width: 50, height: 35 },
                { x: 350, y: 375, type: 'stone', width: 45, height: 35 },
                { x: 400, y: 378, type: 'moss', width: 40, height: 30 },

                // Fourth layer
                { x: 110, y: 335, type: 'moss', width: 40, height: 30 },
                { x: 160, y: 335, type: 'soil', width: 45, height: 35 },
                { x: 210, y: 338, type: 'moss', width: 35, height: 28 },
                { x: 255, y: 335, type: 'water', width: 40, height: 32 },
                { x: 300, y: 335, type: 'soil', width: 45, height: 35 },
                { x: 350, y: 338, type: 'moss', width: 38, height: 28 },

                // Fifth layer - getting precarious
                { x: 135, y: 298, type: 'moss', width: 35, height: 28 },
                { x: 180, y: 295, type: 'water', width: 38, height: 30 },
                { x: 225, y: 298, type: 'moss', width: 35, height: 28 },
                { x: 270, y: 295, type: 'soil', width: 40, height: 32 },
                { x: 320, y: 298, type: 'moss', width: 35, height: 28 },

                // Upper loose elements
                { x: 160, y: 258, type: 'water', width: 35, height: 28 },
                { x: 205, y: 255, type: 'moss', width: 32, height: 26 },
                { x: 250, y: 258, type: 'water', width: 35, height: 28 },
                { x: 295, y: 260, type: 'moss', width: 30, height: 25 },

                // Scattered loose tiles on the sides
                { x: 30, y: 380, type: 'soil', width: 40, height: 32 },
                { x: 25, y: 340, type: 'moss', width: 35, height: 28 },
                { x: 40, y: 290, type: 'stone', width: 45, height: 35 },
                { x: 35, y: 240, type: 'moss', width: 32, height: 26 },

                { x: 430, y: 370, type: 'soil', width: 40, height: 32 },
                { x: 440, y: 320, type: 'moss', width: 35, height: 28 },
                { x: 425, y: 270, type: 'stone', width: 45, height: 35 },
                { x: 435, y: 220, type: 'water', width: 35, height: 28 },

                // Top scattered elements
                { x: 80, y: 200, type: 'moss', width: 30, height: 25 },
                { x: 180, y: 210, type: 'water', width: 32, height: 26 },
                { x: 280, y: 205, type: 'moss', width: 30, height: 25 },
                { x: 380, y: 200, type: 'water', width: 32, height: 26 },

                // A few more at varied heights
                { x: 120, y: 160, type: 'moss', width: 28, height: 24 },
                { x: 240, y: 155, type: 'water', width: 30, height: 25 },
                { x: 340, y: 165, type: 'moss', width: 28, height: 24 },
            ];

            arrangements.forEach((config, index) => {
                createTile(config, index);
            });
        }

        function createTile(config, id) {
            const container = document.getElementById('grid-container');
            const tile = document.createElement('div');
            const typeInfo = tileTypes[config.type];

            tile.className = `tile ${typeInfo.color}`;
            tile.id = `tile-${id}`;
            tile.style.width = `${config.width}px`;
            tile.style.height = `${config.height}px`;
            tile.style.left = `${config.x}px`;
            tile.style.top = `${config.y}px`;

            // Add texture marks (1-3 small marks per tile)
            const numMarks = Math.floor(Math.random() * 3) + 1;
            for (let i = 0; i < numMarks; i++) {
                const mark = document.createElement('div');
                mark.className = 'texture-mark';
                const size = 2 + Math.random() * 3;
                mark.style.width = `${size}px`;
                mark.style.height = `${size}px`;
                mark.style.left = `${15 + Math.random() * 70}%`;
                mark.style.top = `${25 + Math.random() * 50}%`;
                mark.style.background = config.type === 'water'
                    ? 'rgba(255,255,255,0.3)'
                    : 'rgba(0,0,0,0.15)';
                tile.appendChild(mark);
            }

            // Add settled indicator dots (hidden initially, shown when settled)
            for (let i = 0; i < 2; i++) {
                const dot = document.createElement('div');
                dot.className = 'settled-dot';
                const size = 2 + Math.random() * 2;
                dot.style.width = `${size}px`;
                dot.style.height = `${size}px`;
                dot.style.left = `${20 + Math.random() * 60}%`;
                dot.style.top = `${40 + Math.random() * 40}%`;
                dot.style.opacity = '0';
                dot.style.transition = 'opacity 1s ease';
                tile.appendChild(dot);
            }

            // Add crack line element (hidden initially)
            const crackLine = document.createElement('div');
            crackLine.className = 'crack-line';
            crackLine.style.display = 'none';
            tile.appendChild(crackLine);

            container.appendChild(tile);

            state.tiles.push({
                id: id,
                element: tile,
                x: config.x,
                y: config.y,
                width: config.width,
                height: config.height,
                type: config.type,
                weight: typeInfo.weight,
                vx: 0,
                vy: 0,
                stress: 0,
                settled: false,
                settledTime: 0,
                sleeping: false,
                sleepFrames: 0
            });
        }

        // Drag system
        function setupDragListeners() {
            const container = document.getElementById('grid-container');

            container.addEventListener('mousedown', startDrag);
            container.addEventListener('mousemove', doDrag);
            container.addEventListener('mouseup', endDrag);
            container.addEventListener('mouseleave', endDrag);

            // Touch support
            container.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                startDrag({ clientX: touch.clientX, clientY: touch.clientY, target: e.target });
            });
            container.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                doDrag({ clientX: touch.clientX, clientY: touch.clientY });
            });
            container.addEventListener('touchend', endDrag);
        }

        function startDrag(e) {
            const tileElement = e.target.closest('.tile');
            if (!tileElement) return;

            const tileId = parseInt(tileElement.id.replace('tile-', ''));
            const tile = state.tiles.find(t => t.id === tileId);
            if (!tile) return;

            const container = document.getElementById('grid-container');
            const rect = container.getBoundingClientRect();

            state.dragging = tile;
            state.dragOffset = {
                x: e.clientX - rect.left - tile.x,
                y: e.clientY - rect.top - tile.y
            };

            tile.element.classList.add('dragging');
            tile.settled = false;
            tile.vx = 0;
            tile.vy = 0;

            // Small coherence cost for intervention
            state.coherence = Math.max(0, state.coherence - 0.5);
        }

        function doDrag(e) {
            if (!state.dragging) return;

            const container = document.getElementById('grid-container');
            const rect = container.getBoundingClientRect();

            let newX = e.clientX - rect.left - state.dragOffset.x;
            let newY = e.clientY - rect.top - state.dragOffset.y;

            // Constrain to grid
            newX = Math.max(0, Math.min(state.gridWidth - state.dragging.width, newX));
            newY = Math.max(0, Math.min(state.gridHeight - state.dragging.height, newY));

            state.dragging.x = newX;
            state.dragging.y = newY;
            state.dragging.element.style.left = `${newX}px`;
            state.dragging.element.style.top = `${newY}px`;
        }

        function endDrag() {
            if (state.dragging) {
                state.dragging.element.classList.remove('dragging');
                playSound('place');
                state.dragging = null;
            }
        }

        // Physics simulation
        function gameLoop(timestamp) {
            if (!state.running) return;

            const deltaTime = timestamp - state.lastUpdate;
            state.lastUpdate = timestamp;

            if (deltaTime < 100) { // Prevent huge jumps
                updatePhysics(deltaTime);
                updateStress();
                updateCoherence();
                updateVisuals();
                updateMusic(state.coherence);
            }

            requestAnimationFrame(gameLoop);
        }

        function updatePhysics(dt) {
            const gravity = 0.15;
            const friction = 0.8;
            const bounce = 0.3;
            const sleepThreshold = 0.08;
            const sleepFramesRequired = 30;

            state.tiles.forEach(tile => {
                if (tile === state.dragging) return;

                // Check if tile is sleeping (skip physics for stable tiles)
                if (tile.sleeping) {
                    // Check if any neighbor is moving and might wake this tile
                    let shouldWake = false;
                    state.tiles.forEach(other => {
                        if (other === tile || other.sleeping) return;
                        if (tilesOverlap(tile, other) || tilesNearby(tile, other, 5)) {
                            if (Math.abs(other.vx) > sleepThreshold || Math.abs(other.vy) > sleepThreshold) {
                                shouldWake = true;
                            }
                        }
                    });
                    if (shouldWake) {
                        tile.sleeping = false;
                        tile.sleepFrames = 0;
                    } else {
                        return; // Stay asleep, skip physics
                    }
                }

                // Apply gravity
                tile.vy += gravity;

                // Move
                tile.x += tile.vx;
                tile.y += tile.vy;

                // Floor collision
                const floorY = state.gridHeight - tile.height;
                if (tile.y >= floorY) {
                    tile.y = floorY;
                    if (Math.abs(tile.vy) > 1) {
                        playSound('place');
                    }
                    tile.vy *= -bounce;
                    tile.vx *= friction;

                    if (Math.abs(tile.vy) < 0.5) {
                        tile.vy = 0;
                    }
                }

                // Wall collisions
                if (tile.x <= 0) {
                    tile.x = 0;
                    tile.vx *= -bounce;
                }
                if (tile.x >= state.gridWidth - tile.width) {
                    tile.x = state.gridWidth - tile.width;
                    tile.vx *= -bounce;
                }

                // Tile-to-tile collisions
                state.tiles.forEach(other => {
                    if (other === tile || other === state.dragging) return;

                    if (tilesOverlap(tile, other)) {
                        resolveTileCollision(tile, other);
                    }
                });

                // Apply friction when on ground
                if (tile.y >= floorY - 1) {
                    tile.vx *= 0.9;
                }

                // Check if settled and potentially sleeping
                const isVeryStill = Math.abs(tile.vx) < sleepThreshold && Math.abs(tile.vy) < sleepThreshold;
                const isSettled = Math.abs(tile.vx) < 0.1 && Math.abs(tile.vy) < 0.1;

                if (isVeryStill) {
                    tile.sleepFrames++;
                    // Force to complete stillness and enter sleep after enough frames
                    if (tile.sleepFrames > sleepFramesRequired) {
                        tile.vx = 0;
                        tile.vy = 0;
                        tile.sleeping = true;
                    }
                } else {
                    tile.sleepFrames = 0;
                    tile.sleeping = false;
                }

                if (isSettled && !tile.settled) {
                    tile.settledTime++;
                    if (tile.settledTime > 60) {
                        tile.settled = true;
                        tile.element.classList.add('settled');
                        // Show settled dots
                        tile.element.querySelectorAll('.settled-dot').forEach(dot => {
                            dot.style.opacity = '0.5';
                        });
                        playSound('settle');
                    }
                } else if (!isSettled) {
                    tile.settled = false;
                    tile.settledTime = 0;
                    tile.element.classList.remove('settled');
                    // Hide settled dots
                    tile.element.querySelectorAll('.settled-dot').forEach(dot => {
                        dot.style.opacity = '0';
                    });
                }

                // Update element position
                tile.element.style.left = `${tile.x}px`;
                tile.element.style.top = `${tile.y}px`;
            });
        }

        function tilesOverlap(a, b) {
            return a.x < b.x + b.width &&
                   a.x + a.width > b.x &&
                   a.y < b.y + b.height &&
                   a.y + a.height > b.y;
        }

        function tilesNearby(a, b, margin) {
            return a.x - margin < b.x + b.width &&
                   a.x + a.width + margin > b.x &&
                   a.y - margin < b.y + b.height &&
                   a.y + a.height + margin > b.y;
        }

        function resolveTileCollision(tile, other) {
            // Calculate overlap
            const overlapX = Math.min(tile.x + tile.width, other.x + other.width) - Math.max(tile.x, other.x);
            const overlapY = Math.min(tile.y + tile.height, other.y + other.height) - Math.max(tile.y, other.y);

            if (overlapX < overlapY) {
                // Horizontal separation
                if (tile.x < other.x) {
                    tile.x -= overlapX / 2;
                    tile.vx -= 0.5;
                } else {
                    tile.x += overlapX / 2;
                    tile.vx += 0.5;
                }
                playSound('slide');
            } else {
                // Vertical separation
                if (tile.y < other.y) {
                    tile.y = other.y - tile.height;
                    tile.vy = 0;

                    // Transfer some stress downward
                    other.stress += tile.weight * 0.1;
                } else {
                    tile.y = other.y + other.height;
                    tile.vy = Math.abs(tile.vy) * 0.3;
                }
            }
        }

        function updateStress() {
            // Calculate stress for each tile
            state.tiles.forEach(tile => {
                // Decay stress over time
                tile.stress *= 0.95;

                // Check support
                const support = calculateSupport(tile);

                if (support < 0.3 && tile.y < state.gridHeight - tile.height - 5) {
                    // Unsupported - increase stress
                    tile.stress += 0.5;
                }

                // Check weight from above
                const weightAbove = calculateWeightAbove(tile);
                tile.stress += weightAbove * 0.05;

                // Apply stress visual states
                tile.element.classList.remove('strained', 'stressed', 'cracked');
                const crackLine = tile.element.querySelector('.crack-line');
                if (crackLine) crackLine.style.display = 'none';

                if (tile.stress > 8) {
                    tile.element.classList.add('cracked');
                    if (crackLine) crackLine.style.display = 'block';
                    // Chance to break/slide
                    if (Math.random() < 0.02) {
                        tile.vx += (Math.random() - 0.5) * 3;
                        tile.vy -= 1;
                        playSound('crack');
                    }
                } else if (tile.stress > 4) {
                    tile.element.classList.add('stressed');
                } else if (tile.stress > 2) {
                    tile.element.classList.add('strained');
                }
            });
        }

        function calculateSupport(tile) {
            // Check how much of the tile is supported from below
            let supportedWidth = 0;
            const checkY = tile.y + tile.height + 2;

            // Check floor
            if (tile.y >= state.gridHeight - tile.height - 2) {
                return 1;
            }

            // Check other tiles
            state.tiles.forEach(other => {
                if (other === tile) return;

                if (other.y >= checkY && other.y < checkY + 10) {
                    const overlapLeft = Math.max(tile.x, other.x);
                    const overlapRight = Math.min(tile.x + tile.width, other.x + other.width);
                    if (overlapRight > overlapLeft) {
                        supportedWidth += overlapRight - overlapLeft;
                    }
                }
            });

            return Math.min(1, supportedWidth / tile.width);
        }

        function calculateWeightAbove(tile) {
            let weight = 0;

            state.tiles.forEach(other => {
                if (other === tile) return;

                // Check if other is above and overlapping
                if (other.y + other.height < tile.y + 5 &&
                    other.x < tile.x + tile.width &&
                    other.x + other.width > tile.x) {
                    weight += other.weight;
                }
            });

            return weight;
        }

        function updateCoherence() {
            // Calculate coherence based on system state
            let movingTiles = 0;
            let totalStress = 0;
            let settledTiles = 0;

            state.tiles.forEach(tile => {
                if (Math.abs(tile.vx) > 0.5 || Math.abs(tile.vy) > 0.5) {
                    movingTiles++;
                }
                totalStress += tile.stress;
                if (tile.settled) {
                    settledTiles++;
                }
            });

            // Coherence based on ratio of settled vs moving tiles
            // This makes all three states actually reachable
            const totalTiles = state.tiles.length;
            const settledRatio = settledTiles / totalTiles;
            const movingRatio = movingTiles / totalTiles;
            const avgStress = totalStress / totalTiles;

            // Target coherence based on how much of the system is at rest
            // settledRatio of 0.8+ = stillness, 0.4-0.8 = settling, <0.4 = turbulence
            let targetCoherence;

            if (movingTiles <= 2 && avgStress < 1) {
                // Almost everything still and unstressed = high coherence
                targetCoherence = 80 + (settledRatio * 20);
            } else if (movingRatio < 0.15) {
                // Few things moving = settling toward stillness
                targetCoherence = 50 + (settledRatio * 30) - (avgStress * 2);
            } else if (movingRatio < 0.35) {
                // Moderate movement = settling state
                targetCoherence = 35 + (settledRatio * 25) - (avgStress * 1.5);
            } else {
                // Lots of movement = turbulence
                targetCoherence = 20 - (movingRatio * 20) - (avgStress);
            }

            // Natural recovery when nothing is moving
            const recoveryRate = movingTiles === 0 ? 0.04 : 0.02;

            // Smooth transition
            state.coherence += (Math.max(0, Math.min(100, targetCoherence)) - state.coherence) * recoveryRate;
        }

        function updateVisuals() {
            const statusText = document.querySelector('#status .state-text');
            const coherenceField = document.getElementById('coherence-field');

            // Update status text
            statusText.classList.remove('coherent', 'unsettled', 'chaotic');

            if (state.coherence > 65) {
                statusText.textContent = 'stillness';
                statusText.classList.add('coherent');
                coherenceField.classList.remove('low');
                document.body.classList.remove('stressed');
            } else if (state.coherence > 35) {
                statusText.textContent = 'settling';
                statusText.classList.add('unsettled');
                coherenceField.classList.remove('low');
                document.body.classList.remove('stressed');
            } else {
                statusText.textContent = 'turbulence';
                statusText.classList.add('chaotic');
                coherenceField.classList.add('low');
                document.body.classList.add('stressed');
            }
        }

        // Rest state - peaceful listening mode
        let restMode = false;
        let currentRestTrack = 'coherent'; // which track is currently playing in rest mode

        function rest() {
            if (restMode) return; // Already in rest mode

            restMode = true;
            state.running = false; // Stop physics

            const overlay = document.getElementById('fade-overlay');
            overlay.classList.add('active');

            // Fade both tracks to half volume, then play sequentially
            const targetVolume = 0.25;

            const fadeToRest = setInterval(() => {
                let done = true;

                if (audioCoherent.volume > targetVolume + 0.02) {
                    audioCoherent.volume -= 0.02;
                    done = false;
                } else {
                    audioCoherent.volume = targetVolume;
                }

                if (audioChaotic.volume > 0.02) {
                    audioChaotic.volume -= 0.02;
                    done = false;
                } else {
                    audioChaotic.volume = 0;
                    audioChaotic.pause();
                }

                if (done) {
                    clearInterval(fadeToRest);
                    // Start sequential playback - coherent track plays first
                    setupRestPlayback();
                }
            }, 100);
        }

        function setupRestPlayback() {
            // When coherent track ends, play chaotic track
            audioCoherent.loop = false;
            audioChaotic.loop = false;

            audioCoherent.onended = () => {
                if (!restMode) return;
                currentRestTrack = 'chaotic';
                audioChaotic.volume = 0.25;
                audioChaotic.currentTime = 0;
                audioChaotic.play();
            };

            audioChaotic.onended = () => {
                if (!restMode) return;
                currentRestTrack = 'coherent';
                audioCoherent.volume = 0.25;
                audioCoherent.currentTime = 0;
                audioCoherent.play();
            };
        }

        function wake() {
            if (!restMode) return; // Not in rest mode

            restMode = false;

            // Restore loop behavior
            audioCoherent.loop = true;
            audioChaotic.loop = true;

            // Clear the onended handlers
            audioCoherent.onended = null;
            audioChaotic.onended = null;

            // Fade out overlay
            const overlay = document.getElementById('fade-overlay');
            overlay.classList.remove('active');

            // Gradually restore music to normal levels based on current coherence
            const fadeToWake = setInterval(() => {
                let done = true;
                const targetCoherent = 0.1 + (state.coherence / 100) * 0.4;
                const targetChaotic = 0.4 - (state.coherence / 100) * 0.35;

                // Fade coherent track
                const diffCoherent = targetCoherent - audioCoherent.volume;
                if (Math.abs(diffCoherent) > 0.02) {
                    audioCoherent.volume += diffCoherent * 0.1;
                    done = false;
                }

                // Start and fade in chaotic track if needed
                if (audioChaotic.paused && targetChaotic > 0.02) {
                    audioChaotic.volume = 0;
                    audioChaotic.play().catch(err => console.log('Audio error:', err));
                }

                const diffChaotic = targetChaotic - audioChaotic.volume;
                if (Math.abs(diffChaotic) > 0.02) {
                    audioChaotic.volume += diffChaotic * 0.1;
                    done = false;
                }

                if (done) {
                    clearInterval(fadeToWake);
                }
            }, 100);

            // Resume physics
            state.running = true;
            state.lastUpdate = performance.now();
            requestAnimationFrame(gameLoop);
        }

        // Keyboard support for init
        document.addEventListener('keydown', (e) => {
            const audioInitActive = !document.getElementById('audio-init').classList.contains('hidden');

            if (audioInitActive && (e.key === 'Enter' || e.key === ' ')) {
                e.preventDefault();
                initAudio();
            }
        });
    </script>
</body>
</html>
